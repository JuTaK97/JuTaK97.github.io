---
title : Chapter 9. Virtual Memory - Dynamic Memory Allocation
categories : 
  - C
use_math : true
comments : true
tags :
  - C
last_modified_at: 2022-04-19T20:08:00-05:00
---
# Computer Systems : A Programmer's Perspective (CSAPP)
<br /><br />
## 9.9 Dynamic Memory Allocation

9.8절에서 살펴본 `mmap`과 `munmap` 함수로도 low-level에서 가상 메모리의 영역을 생성하고 삭제할 수 있다. 하지만 run-time에서 필요한 가상 메모리를 얻고자 할 때는 _dynamic memory allocator_ 를 사용하는 것이 훨씬 편리하다.<br />

Dynamic memory allocator는 heap이라고 부르는 프로세스의 가상 메모리 영역을 관리한다. 시스템마다 구체적인 것은 다르겠지만, heap은 uninitialized data(.bss 영역) 위부터 시작해서 위쪽으로 올라가는 영역이다. 커널은 각 프로세스마다 heap의 가장 위쪽을 가리키는 포인터 `brk`을 관리한다.<br />

Allocator는 heap을 여러 _block_ 들의 집합체로 관리하는데, 각 block은 allocated / free 둘 중 하나의 상태에 있는 가상 메모리의 연속된 뭉치(contiguous chunk)이다. Allocated 블록은 현재 응용 프로그램이 사용 중이라고 명시적으로 맡아 놓은 상태이고, free block은 새로 할당될 수 있는 상태이다. Free block은 따로 할당할 때까지 계속 free 상태이고, allocated block은은 응용 프로그램에서 직접, 혹은 memory allocator이 내부적으로 free하기 전까지 allocated 상태로 남는다.<br />

Allocator에는 두 가지 스타일이 있다. 두 스타일 모두 새 블록을 할당하는 건 응용 프로그램(application)에게 맡기지만 free하는 것을 누구에게 맡길지에는 차이가 있다.
- Explicit allocators : 응용 프로그램에서 명시적으로 할당됐던 블록을 free 하도록 한다. 이를 위한 함수들은 C 표준 라이브러리에서 `malloc` 패키지의 함수들에 제공된다.
- Implicit allocators : 위와 반대로 allocator가 직접 더이상 사용되지 않는 할당된 블록을 찾아서 free 하도록 한다. Garbage collector라고도 불리고 ML, Lisp, Java 등의 고급 언어에서 사용된다.

### 9.9.1 The malloc and free Functions

C 표준 라이브러리는 `malloc` 패키지라고도 알려진 expliit allocator를 제공한다.<br />

```c
#include <stdlib.h>
void *malloc(size_t size);
```

`malloc` 함수를 불러서 heap의 블록을 할당할 수 있다. 반환값은 할당한 블록의 포인터인데, 이때 요청된 `size` 바이트만큼 딱 할당되지 않고 특정 단위로 aligned되어 할당된다. 예를 들어 32비트 모드에서는 8바이트 단위로 aligned된 블록을 할당하고 64비트에서는 16바이트 단위로 align해서 할당한다.<br />

사용 가능한 가상 메모리를 초과하는 등의 문제가 생겼을 경우 NULL을 반환하고 errno의 값을 설정한다. 또한 `malloc`은 할당한 블록의 초기값을 따로 설정하지 않는다. 초기화를 하고 싶은 경우 wrapper function인 `calloc`을 사용하면 되고, 이전에 할당한 블록의 크기를 바꾸고 싶은 경우 `realloc`을 사용한다.<br /><br />

`mmap`과 `munmap`으로 직접 heap을 할당하거나 할당 해제할 수도 있지만 `sbrk` 함수를 이용할 수도 있다.
```c
#include <stdlih.b>
void *sbrk(intptr_t incr);
```
`sbrk` 함수는 커널이 관리하는 brk 포인터에 `incr`만큼 더해서 heap을 올리거나(grow) 내릴 수 있다(shrink). 반환값은 변하기 전 brk의 값이고, 에러인 경우는 -1을 반환하고 errno의 값을 ENOMEM으로 설정한다. `incr`이 0이면 현재 brk를 반환하고,`incr`이 음수인 경우도 동작한다.  <br /><br />

프로그램은 `free` 함수를 이용해서 heap에 할당된 블록을 할당 해제할 수 있다.
```c
#include <stdlih.b>
void free(void *ptr);
```
`free` 함수는 반드시 `malloc`, `calloc`, `realloc`으로 할당했던 블록의 시작 부분 포인터를 argument로 넣어 줘야 한다. 그렇지 않으면 undefined behavior가 발생하는데 반환값도 원래 없기 때문에 무언가 잘못되었다고 알려주는 것도 없다. 9.11절에서 이런 경우 발생하는 run-time error를 살펴볼 것이다.<br />

예시를 통해서 `malloc`과 `free`의 동작을 간단히 살펴보자.

![image](https://user-images.githubusercontent.com/88367636/164015628-3069a0f0-4ed0-413d-8191-d1dcf446313c.png)
 
한 칸은 1 word(=4 byte)를 의미하고, 이 예시에서는 8-byte align된다고 가정한다.<br />

주목할 부분은 (b)이다. 5 word를 `malloc`했지만 우리는 2 word 단위로 align하기 때문에 마지막 한 word는 남겨둔다. 그리고 (c)에서 6 word를 할당하면 pad된 곳 이후부터 할당한다.<br />
(d)에서 p2가 가리키는 블록을 free하면, p2가 가리키던 5 word는 새로 할당될 수 있는 상태가 되어서 (e)에서 p4가 이곳을 할당받게 된다. 하지만 포인터 p2는 아직 저곳을 가리키고 있기 때문에 사용자는 p2를 다시 사용하지 않도록 주의해야 한다.

### 9.9.2 Why Dynamic Memory Allocation?

'동적' 메모리 할당의 가장 중요한 점은, 사용자가 프로그램을 돌리기 전까지 얼마나 할당될 지 보통 알지 못한다는 것이다. <br />
만약 우리가 stdin으로 문자열을 입력받아 저장하는 프로그램을 짠다고 하면, 가장 단순한 방법은 MAX값을 큰 수로 설정해서 크기가 하드코딩된 배열을 사용하는 것이다. <br />
하지만 이는 좋은 방법이 아니다. 임의로 설정한 MAX라는 값은 실제 프로그램과 아무 관련도 없기도 하고, 배열의 크기를 하드코딩해 놓으면 그 이상의 입력이 들어왔을 때의 유일한 대처 방법은 MAX를 더 크게 잡고 다시 컴파일하는 것 뿐이다. 수백만 줄의 코드와 수많은 사용자가 있는 응용 프로그램에서 이렇게 하드코딩된 배열 크기는 유지보수에 있어 악몽과도 같은 상황을 만들게 된다. <br /><br />

더 나은 방법은 run time에 배열의 크기 n이 정해지고 나서 배열을 위한 메모리를 동적으로 할당하는 것이다. 이 방법을 사용하면 배열 크기를 제한하는 것은 가상 메모리의 전체 용량뿐이다.<br />
동적 메모리 할당은 아주 유용하고 중요한 기술이지만 잘 알고 사용하지 않으면 여러 에러가 발생할 수 있다. 이는 9.11절에서 다룬다.

### 9.9.3 Allocator Requirements and Goals

Explicit allocator는 다음과 같은 꽤 엄격한 제약 조건 하에서 작동해야 한다.

- 임의로 들어오는 요청들에 대응할 수 있어야 한다. <br /> 프로그램은 allocate/free 요청을 임의의 순서(단, free는 할당했던 블록만)로 할 수 있기 때문에 allocator는 alloc 후 free가 꼭 나온다던가, alloc과 free가 짝을 이루어 nested된다던가 하는 가정을 할 수 없다.
- 요청에 즉시 대응해야 한다.<br />alloc/free 요청들의 순서를 바꾼다던가 buffer을 사용한다던가 할 수 없다. 할당 요청이 오면 즉시 대응한다.
- Heap만 사용해야 한다. 
- Aligned되도록 할당해야 한다.
- 할당된 블록은 수정할 수 없다. <br /> Allocator는 free 블록만 건드릴 수 있고, 일단 할당된 블록은 수정하거나 위치를 옮길 수 없다. 따라서 성능을 올리기 위해 할당된 블록들을 compaction한다던가 할 수 없다.

이런 제약 조건 하에서 allocator는 두 가지 관점에서의 성능을 높여야 한다.
- 목표 1: Throughput을 최대로 <br />  Throughput이란 단위 시간당 처리할 수 있는 요청의 개수이다. 예를 들어 1초에 500번 alloc, 500번 free할 수 있다면 throughput은 1000/s가 된다.<br /> alloc/free 요청에 걸리는 시간을 줄여서 throughput을 최대화할 수 있다. 최악의 경우에 alloc에 걸리는 시간을 free block 개수에 선형으로, free에 걸리는 시간은 상수로 하는 allocator를 만드는 것은 크게 어렵지는 않다.<br />
- 목표 2: Memory utilization을 최대로 <br /> 초보 프로그래머는 가상 메모리가 무제한이라고 착각하곤 한다. 하지만 시스템 내에서 모든 프로세스가 할당받을 수 있는 가상 메모리는 디스크의 swap space 만큼으로 제한되어 있다. <br /> 가상 메모리도 효율적으로 사용해야 하는 유한한 자원이고, 크기가 큰 블록을 alloc/free할 때 특히 그렇다.<br /><br /> 

Allocator가 heap을 얼마나 효율적으로 사용하는지는 여러 방법으로 살펴볼 수 있다.<br />
가장 유용한 측도는 _peak utilization_ 이다. 단조증가하는 Heap의 크기를 $H_k$ 라고 하고 n개의 alloc/free 요청들 $R_0, R_1, ..., R_{n-1}$ 이 들어온다고 하자. k번째 요청에 대한 동작이 끝난 시점에서 할당된 블록들의 payload의 총 합을 $P_k$ 라고 했을 때, peak utilization $U_k$는 $\frac{{max}_{1<=k} P_{i}}{H_k}$ 이다.

