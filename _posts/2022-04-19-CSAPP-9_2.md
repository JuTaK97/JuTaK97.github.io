---
title : Chapter 9. Virtual Memory - Dynamic Memory Allocation
categories : 
  - C
use_math : true
comments : true
tags :
  - C
last_modified_at: 2022-04-19T20:08:00-05:00
---
# Computer Systems : A Programmer's Perspective (CSAPP)
<br /><br />
## 9.9 Dynamic Memory Allocation

9.8절에서 살펴본 `mmap`과 `munmap` 함수로도 low-level에서 가상 메모리의 영역을 생성하고 삭제할 수 있다. 하지만 run-time에서 필요한 가상 메모리를 얻고자 할 때는 _dynamic memory allocator_ 를 사용하는 것이 훨씬 편리하다.<br />

Dynamic memory allocator는 heap이라고 부르는 프로세스의 가상 메모리 영역을 관리한다. 시스템마다 구체적인 것은 다르겠지만, heap은 uninitialized data(.bss 영역) 위부터 시작해서 위쪽으로 올라가는 영역이다. 커널은 각 프로세스마다 heap의 가장 위쪽을 가리키는 포인터 `brk`을 관리한다.<br />

Allocator는 heap을 여러 _block_ 들의 집합체로 관리하는데, 각 block은 allocated / free 둘 중 하나의 상태에 있는 가상 메모리의 연속된 뭉치(contiguous chunk)이다. Allocated 블록은 현재 응용 프로그램이 사용 중이라고 명시적으로 맡아 놓은 상태이고, free block은 새로 할당될 수 있는 상태이다. Free block은 따로 할당할 때까지 계속 free 상태이고, allocated block은은 응용 프로그램에서 직접, 혹은 memory allocator이 내부적으로 free하기 전까지 allocated 상태로 남는다.<br />

Allocator에는 두 가지 스타일이 있다. 두 스타일 모두 새 블록을 할당하는 건 응용 프로그램(application)에게 맡기지만 free하는 것을 누구에게 맡길지에는 차이가 있다.
- Explicit allocators : 응용 프로그램에서 명시적으로 할당됐던 블록을 free 하도록 한다. 이를 위한 함수들은 C 표준 라이브러리에서 `malloc` 패키지의 함수들에 제공된다.
- Implicit allocators : 위와 반대로 allocator가 직접 더이상 사용되지 않는 할당된 블록을 찾아서 free 하도록 한다. Garbage collector라고도 불리고 ML, Lisp, Java 등의 고급 언어에서 사용된다.

### 9.9.1 The malloc and free Functions

C 표준 라이브러리는 `malloc` 패키지라고도 알려진 expliit allocator를 제공한다.<br />

```c
#include <stdlib.h>
void *malloc(size_t size);
```

`malloc` 함수를 불러서 heap의 블록을 할당할 수 있다. 반환값은 할당한 블록의 포인터인데, 이때 요청된 `size` 바이트만큼 딱 할당되지 않고 특정 단위로 aligned되어 할당된다. 예를 들어 32비트 모드에서는 8바이트 단위로 aligned된 블록을 할당하고 64비트에서는 16바이트 단위로 align해서 할당한다.<br />

사용 가능한 가상 메모리를 초과하는 등의 문제가 생겼을 경우 NULL을 반환하고 errno의 값을 설정한다. 또한 `malloc`은 할당한 블록의 초기값을 따로 설정하지 않는다. 초기화를 하고 싶은 경우 wrapper function인 `calloc`을 사용하면 되고, 이전에 할당한 블록의 크기를 바꾸고 싶은 경우 `realloc`을 사용한다.<br /><br />

`mmap`과 `munmap`으로 직접 heap을 할당하거나 할당 해제할 수도 있지만 `sbrk` 함수를 이용할 수도 있다.
```c
#include <unistd.h>
void *sbrk(intptr_t incr);
```
`sbrk` 함수는 커널이 관리하는 brk 포인터에 `incr`만큼 더해서 heap을 올리거나(grow) 내릴 수 있다(shrink). 반환값은 변하기 전 brk의 값이고, 에러인 경우는 -1을 반환하고 errno의 값을 ENOMEM으로 설정한다. `incr`이 0이면 현재 brk를 반환하고,`incr`이 음수인 경우도 동작한다.  <br /><br />

프로그램은 `free` 함수를 이용해서 heap에 할당된 블록을 할당 해제할 수 있다.
```c
#include <stdlih.b>
void free(void *ptr);
```
`free` 함수는 반드시 `malloc`, `calloc`, `realloc`으로 할당했던 블록의 시작 부분 포인터를 argument로 넣어 줘야 한다. 그렇지 않으면 undefined behavior가 발생하는데 `free`는 원래 반환값이 없기 때문에 무언가 잘못되었다고 알려주지 않는다. 9.11절에서 이런 경우 발생하는 run-time error를 살펴볼 것이다.<br />

예시를 통해서 `malloc`과 `free`의 동작을 간단히 살펴보자.

![image](https://user-images.githubusercontent.com/88367636/164015628-3069a0f0-4ed0-413d-8191-d1dcf446313c.png)
 
한 칸은 1 word(=4 byte)를 의미하고, 이 예시에서는 8-byte align된다고 가정한다.<br />

주목할 부분은 (b)이다. 5 word를 `malloc`했지만 우리는 2 word 단위로 align하기 때문에 마지막 한 word는 남겨둔다. 그리고 (c)에서 6 word를 할당하면 pad된 곳 이후부터 할당한다.<br />
(d)에서 p2가 가리키는 블록을 free하면, p2가 가리키던 5 word는 새로 할당될 수 있는 상태가 되어서 (e)에서 p4가 이곳을 할당받게 된다. 하지만 포인터 p2는 아직 저곳을 가리키고 있기 때문에 사용자는 p2를 다시 사용하지 않도록 주의해야 한다.

### 9.9.2 Why Dynamic Memory Allocation?

'동적' 메모리 할당의 가장 중요한 점은, 사용자가 프로그램을 돌리기 전까지 얼마나 할당될 지 보통 알지 못한다는 것이다. <br />
만약 우리가 stdin으로 문자열을 입력받아 저장하는 프로그램을 짠다고 하면, 가장 단순한 방법은 MAX값을 큰 수로 설정해서 크기가 하드코딩된 배열을 사용하는 것이다. <br />
하지만 이는 좋은 방법이 아니다. 임의로 설정한 MAX라는 값은 실제 프로그램과 아무 관련도 없기도 하고, 배열의 크기를 하드코딩해 놓으면 그 이상의 입력이 들어왔을 때의 유일한 대처 방법은 MAX를 더 크게 잡고 다시 컴파일하는 것 뿐이다. 수백만 줄의 코드와 수많은 사용자가 있는 응용 프로그램에서 이렇게 하드코딩된 배열 크기는 유지보수에 있어 악몽과도 같은 상황을 만들게 된다. <br /><br />

더 나은 방법은 run time에 배열의 크기 n이 정해지고 나서 배열을 위한 메모리를 동적으로 할당하는 것이다. 이 방법을 사용하면 배열 크기를 제한하는 것은 가상 메모리의 전체 용량뿐이다.<br />
동적 메모리 할당은 아주 유용하고 중요한 기술이지만 잘 알고 사용하지 않으면 여러 에러가 발생할 수 있다. 이는 9.11절에서 다룬다.

### 9.9.3 Allocator Requirements and Goals

Explicit allocator는 다음과 같은 꽤 엄격한 제약 조건 하에서 작동해야 한다.

- 임의로 들어오는 request들에 대응할 수 있어야 한다. <br /> 프로그램은 allocate/free 요청을 임의의 순서(단, free는 할당했던 블록에 대해서만)로 할 수 있기 때문에 allocator는 alloc 후 free가 꼭 나온다던가, alloc과 free가 짝을 이루어 nested된다던가 하는 가정을 할 수 없다.
- Request에 즉시 대응해야 한다.<br />alloc/free 요청들의 순서를 바꾼다던가 buffer을 사용한다던가 할 수 없다. 할당 요청이 오면 즉시 대응한다.
- Heap만 사용해야 한다. 
- Aligned되도록 할당해야 한다.
- 할당된 블록은 수정할 수 없다. <br /> Allocator는 free 블록만 건드릴 수 있고, 일단 할당된 블록은 수정하거나 위치를 옮길 수 없다. 따라서 성능을 올리기 위해 할당된 블록들을 compaction한다던가 할 수 없다.

이런 제약 조건 하에서 allocator는 두 가지 관점에서의 성능을 높여야 한다.
- 목표 1: Throughput을 최대로 <br />  Throughput이란 단위 시간당 처리할 수 있는 요청의 개수이다. 예를 들어 1초에 500번 alloc, 500번 free할 수 있다면 throughput은 1000/s가 된다.<br /> alloc/free 요청에 걸리는 시간을 줄여서 throughput을 최대화할 수 있다. 최악의 경우에 alloc에 걸리는 시간을 free block 개수에 선형으로, free에 걸리는 시간은 상수로 하는 allocator를 만드는 것은 크게 어렵지는 않다.<br />
- 목표 2: Memory utilization을 최대로 <br /> 초보 프로그래머는 가상 메모리가 무제한이라고 착각하곤 한다. 하지만 시스템 내에서 모든 프로세스가 할당받을 수 있는 가상 메모리는 디스크의 swap space 만큼으로 제한되어 있다. <br /> 가상 메모리도 효율적으로 사용해야 하는 유한한 자원이고, 크기가 큰 블록을 alloc/free할 때 특히 그렇다.<br /><br /> 

Allocator가 heap을 얼마나 효율적으로 사용하는지는 여러 방법으로 살펴볼 수 있다.<br />
가장 유용한 측도는 _peak utilization_ 이다. 단조증가하는 Heap의 크기를 $H_k$ 라고 하고 n개의 alloc/free 요청들 $R_0, R_1, ..., R_{n-1}$ 이 들어온다고 하자. k번째 요청에 대한 동작이 끝난 시점에서 할당된 블록들의 payload의 총 합을 $P_k$ 라고 했을 때, peak utilization $U_k$는 다음과 같다.
$$U_k = \frac{max_{1<=k} P_{i}}{H_k}$$

<br />
Allocator의 목적은 전체 sequence에서 peak utilization $U_{n-1}$를 최대로 만드는 것이다. 곧 보겠지만, throughput과 peak utilization 간에는 trade-off가 존재해서 heap utilization을 포기하면 throughput을 최대로 하는 allocator를 쉽게 만들 수 있다. 여기서 중요한 도전 과제는 둘 사이의 적절한 균형을 찾는 것이 된다.

### 9.9.4 Fragmentation

Heap utilization이 낮아지는 주요한 원인은 _fragmentation_ 이라고 불리는 현상으로, 사용 중이 아닌 메모리가 할당 요청을 만족시킬 수 없는 경우 발생한다.<br />
_Internal fragmentation_ 은 할당된 블록이 실제 사용되는 용량(payload)보다 큰 경우 발생한다. 발생하는 원인은 여러 가지인데, 예를 들어 allocator가 메모리 블록을 할당할 때 요청받은 payload보다 큰 블록 중에 최소의 크기인 것에 할당하는 식으로 구현되었을 수도 있지만 앞 그림의 (b)처럼 allocator는 alignment를 맞추기 위해 블록의 크기를 payload보다 크게 할 수도 있다.<br />

Internal fragmentation은 수량화하기 쉽다. 단순하게 할당된 블록의 크기와 payload 간의 차를 모두 합산하면 된다. 따라서 internal fragmentation의 크기는 어느 순간에 재더라도 이전 요청들과 allocator의 구현 방식에만 의존한다. <br />

_External fragmentation_ 은 할당 요청을 만족하기 위한 총 메모리는 충분하지만, 여러 개로 쪼개져 있어서 크기를 만족하는 '단일' 블록이 존재하지 않는 경우 발생한다. 예를 들어 앞 그림의 (e)에서 malloc(8)이었다면 분명 heap에는 총 8-word의 공간이 있지만 이 크기를 만족하는 단일 블록이 존재하지 않기 때문에 커널에게 요청해서 추가로 가상 메모리를 받지 않으면 요청을 수행할 수 없다. <br />

External fragmentation은 internal fragmentation보다 훨씬 수량화하기 어렵다. 왜냐하면 이전 요청들의 패턴과 allocator의 구현 방식 뿐만 아니라 미래의 요청들의 패턴에도 의존하기 때문이다. 예를 들어 k개의 요청을 처리하고 나서 모든 free block이 4-word 크기인 상태라고 하면 이 heap은 external fragmentation에 의한 문제가 발생할까? 답은 앞으로 들어올 요청에 따라 다르다. 이후로 들어오는 요청이 모두 4-word 미만의 할당이라면 문제가 없겠지만 그보다 큰 할당 요청이 들어온다면 문제가 발생하게 된다.<br />
External fragmentation은 수량화하기도 어렵고 예측도 힘들기 때문에 allocator들은 작은 블록 여러개보다는 큰 블록 몇 개를 유지하기 위해 여러 휴리스틱을 사용한다.

### 9.9.5 Implementation Issues

가장 단순한 allocator는 heap을 거대한 하나의 배열과 그 배열의 첫 바이트를 가리키는 포인터 p로 만들 수 있다. `size` 바이트를 할당하려면 malloc은 현재 p의 값을 저장하고, 포인터 p를 `size`만큼 위로 올린 다음 저장해 놓은 p를 caller에게 반환한다. `free`는 아무 것도 할 필요가 없다.<br />
이 방법은 정말 단순해서 throughput은 극대화시키지만 그 어떤 메모리 블록도 재사용되지 않기 때문에 memory utilization 면에서는 최악이 된다. Throughput과 utilization의 균형을 잘 잡는 allocator는 다음 문제들을 고려해야 한다.

- Free block organization : free block들을 어떻게 추적할 것인가?
- Placement : 새로 할당할 때 어떤 free block을 골라서 할당하는 것이 가장 적절한가?
- Splitting: free block에 새로 할당했다면 기존 free block에서 할당하고 남은 부분은 어떻게 하는가?
- Coalescing: free된 블록에는 어떤 일을 해 주어야 하는가?

이 절의 나머지 부분에서는 이 문제들을 자세히 살펴볼 것이다. Placement, splitting, coalescing의 기본적인 기술은 여러 free block organization에도 적용되기 때문에, 이 문제들의 해결 방법을 implicit free list라고 하는 단순한 free block organization을 통해 소개한다.

### 9.9.6 Implicit Free Lists

Allocator는 allocated block과 free block을 구분하고 블록의 경계를 구분하기 위한 어떤 자료구조를 사용해야 한다. 대부분의 allocator는 블록 자체에 이 정보를 탑재하는데, 한 가지 간단한 방법은 아래 그림과 같다.

![image](https://user-images.githubusercontent.com/88367636/164467985-4d882ce5-187f-46de-9ee2-b2e364102f31.png)

하나의 블록이 1-word짜리 헤더, payload, 그리고 추가적인 padding(선택)으로 구성된다. 헤더에는 블록의 크기(물론, 헤더 및 padding 포함)와 block의 상태(alloc인지, free인지)에 대한 정보가 들어 있다. 만약 우리가 double-word alignment를 적용한다면 헤더에서 블록의 크기는 항상 8의 배수이고 블록 크기를 나타내는 비트에서 LSB 3개 비트는 항상 0이 된다. 그래서 우리는 MSB 29개만 블록 크기 저장에 쓰고 남은 3개 비트에는 다른 정보를 저장한다.<br />
3개 비트 중 LSB에 이 블록이 alloc 상태인지 free 상태인지를 저장하게 되는데, 예를 들어서 24바이트를 할당한다면 할당된 블록의 헤더에는
```
0x00000018 | 0x1 = 0x00000019
```
가 저장되어 있을 것이다.<br /><br />

헤더 다음으로 오는 것은 실제로 할당된 메모리 부분(payload)이고, 그 다음으로 오는 것은 padding이다. <br />
크기도 정해지지 않고 사용하지 않는 부분인 padding을 붙이는 이유에는 여러 가지가 있을 수 있다. Externel fragmentation을 줄이기 위한 allocator의 전략의 일환일 수도 있고 align requirement때문에 필요한 부분일 수도 있다.<br /><br />

위 그림과 같은 블록 구조를 사용하면, 연속된 여러 블록들의 sequence로 heap을 구성할 수 있다. 아래 그림과 같다.

![image](https://user-images.githubusercontent.com/88367636/164471937-6258a610-16d0-48d0-9ef2-80f8a13ecf49.png)

우리는 이를 implicit free list라고 부른다. 왜 implicit이냐면 free block들의 연결 관계가 각 블록의 헤더들의 블록 크기 정보에 내포되어 있기 때문이다. Allocator는 모든 블록을 탐색해서 간접적으로 free block들 전부를 돌아볼 수 있다. <br />
여기서 특별히 표시된 end block이 있는 것을 주목하자. 위 그림에서는 헤더에 크기가 0이고 alloc 상태로 표시된 블록이 마지막에 존재한다. 9.9.12절에서 다루겠지만, 이렇게 하면 free block들을 병합하는 과정을 단순화할 수 있다.<br />
Implicit free list의 장점은 단순하다는 것이지만, free list에서 searching이 오래 걸린다는 큰 단점이 있다. 새 블록을 할당하려면 heap에 있는 블록 전체의 수에 선형적으로 비례하는 탐색 시간이 걸리게 된다.<br />












