---
title : "Chapter 14. The Preprocessor"
categories : 
  - C
tags :
  - C
last_modified_at: 2020-03-10T12:33:00-05:00
---
# K.N.KING C PROGRAMMING *A Modern Approach*
## 14.1 How the Preprocessor Works
### Macro definition<br />
**```#define```** <br />
marco를 정의하기 위한 directive이다. Preprocessor는 \#define을 통해 정의된 macro의 이름(=syntax)과 정의(=semantic)를 저장하고, 프로그램에서 매크로가 사용될 때 정의된 값으로 대체한다. <br />
### File inclusion<br />
```#include``` <br />
특정 파일의 content를 해당 프로그램에 포함시킨다. <br/>
- Conditional compilation<br />
```#if```, ```#ifdef```, ```ifndef```, ```#elif```, ```#else```<br />
특정 조건에 따라 코드의 각 부분들이 프로그램에서 포함될지 제외될지를 결정한다. preprocessing 단계에서 이루어진다.

## 14.2 Preprocessing Directives
### Directive 작성의 몇 가지 rule들
1. Directive는 반드시 ```#```로 시작해야 한다. ```#``` 앞에 white space만 있다면 line의 시작이 꼭 아니어도 되지만, 
```#``` 뒤에 나오는 부분은 반드시 그 directive의 정보에 대한 것이어야 한다.
2. ```# define N 100```과 같이, 사이사이에 space나 tab으로 분리되어도 괜찮다.
3. Directive는 ```\n```이 나올 때 끝난다. 여러 줄에 걸쳐서 쓰고 싶으면. ```\```로 줄바꿈을 해서 쓴다.
4. Directive는 프로그램의 어느 부분에서든 나와도 된다. 꼭 맨 앞일 필요는 없다.
5. Directive 오른쪽에 주석은 써도 된다. 설명을 쓰는 것이 가독성에 좋다.


## 14.3 Macro Definition
### Simple Macros
아무 파라미터 없이, 단순한 replacement를 위한 macro이다.<br />
``` C
#define identifier replacement-list 
```
특정 상수를 정의하거나, 자주 쓰이는 문구를 축약하는 데 좋다. 프로그램의 가독성을 높이는 데 도움이 되고, 프로그램 수정을 쉽게 만들어 주는 장점이 있다.
### Parameterized Macros
``` C
#define identifier(x1, x2, ..., xn) replacement-list
```
마치 함수 같은 형태를 가지고 있다.<br />
Preprocessor는 프로그램에서 저 형태의 코드를 발견했을 때, 예를 들어 ```#define identifier(y1, y2, ..., yn)```이 있으면 각 y1 ~ yn을 replacement-list에 정의된
것들로 치환하게 된다.<br /><br />
(예시)
> ``` C
> #define MAX(x, y) ((x)>(y) ? (x) : (y))
> i = MAX(j+k, m-n);
> /* i = ((j+k)>(m-n) ? (j+k) : (m-n)) 과 동일 */
> ```

간편한 함수를 하나 만드는 것과 사실상 동일하다. <br /> <br />
parameter가 없는 parameterized macro도 만들 수 있다.
> ``` C
> #define getchar() getc(stdin)
> ```


### parameterized macro의 장점
1. function에 비해 빠르다. Run-time overhead가 없기 때문이다.
2. Generic하다. 함수의 경우 argument의 타입이 정해져 있지만, macro는 그렇지 않다.

### parameterized macro의 단점
1. 컴파일 후 source code가 아주 길어질 수 있다. 특히 nested되었을 경우 함수를 쓰는 것보다 훨씬 코드가 길어진다.
2. Argument의 type-check가 이루어지지 않는다. preprocessor가 잡아내지도 못하고, type conversion도 받지 못한다.
3. 함수 포인터와 다르게 macro는 포인터를 가질 수 없다.
4. 특정 상황에서 unexpected behavior를 보일 수 있는데 :
> ``` C
> #define MAX(x, y) ((x)>(y) ? (x) : (y))
> int n = MAX(i++, j); 
> ```

이런 코드의 경우, 함수로 구현되었을 때는 i++가 당연히 한 번만 수행되지만, 매크로로 정의하면 (x)가 등장하는 두 군데에서 모두 ++ 연산을 하게 된다.<br /> 

### The # Operator
\# operator는 "stringization"을 하는 operator이다.<br />
사용법은 다음과 같다.
>``` C
>#define PRINT_INT(n) printf(#n " = $%d\n", n)
>PRINT_INT(i/j);
>```

위 코드는 preprocessor를 거치면 아래와 같이 바뀌게 된다.
>``` C
>#define PRINT_INT(n) printf(#n " = %d\n", n)
>printf("i/j" " = %d\n", n);
>```

macro의 replacement-list에 #n이 있고, preprocessor는 코드의 ```PRINT_INT()```를 보고 이곳이구나! 하고 n 대신 i/j로 replace하게 된다.<br />
이때 양 옆으로 " " 가 감싸진다.<br />
그리고 ```printf("string1" "string2");```는 알아서 ```printf("string1", "string2");```로 바뀌기 때문에 콤마는 없어도 된다.

### The ## Operator
\## operator는 두 token을 하나의 token으로 paste해 주는 역할을 한다. 예시를 보자.
>``` C
>#define MK_ID(n) i##n
>#define MK_KD(n) k##n
>int MK_ID(1)=3;
>int MK_KD(2)=4;
>```

Preprocessor는 코드의 MK_ID를 보고 이곳이구나! 하고 작업을 시작한다. 두 token i와 n이 있다. 이중 n만 유저가 써준 1을 가져와서 `int i1=3;`이 된다.
MK_KD의 경우도 `int k2=4;`가 된다. 변수 이름을 규칙적으로 지을 때 쓸모가 있어 보이나.. 사실 ## operator는 잘 쓰이지 않는다고 한다.<br />
대신 동일한 Generic한 함수를 구현하는 데 유용하게 사용된다.
>``` C
>#define GENERIC_MAX(type) type type##max(type x, type y) 
>{ 
>   return x>y ? x : y; 
>}
>GENERIC_MAX(float);
>```

위 macro를 살펴 보면, parameter type으로 뭔가가 들어오면 replacement-list의 type들이 전부 그것으로 대체된다. ## operator가 있는 부분은 concat되어 대체된다.<br />
따라서 preprocessor의 처리가 끝나면 아래와 같이 변경된다.
>``` C
>#define GENERIC_MAX(type) type type_##max(type x, type y) \
>{                                                         \
>   return x>y ? x : y;                                    \
>}
>float float_max(float x, float y)
>{
>   return x>y ? x : y;
>}
>```

parameter 'type'에 넣고 싶은 자료형을 넣으면 해당 자료형에 대한 그 함수를 만들 수 있는 것이다.

### General Properties of Macros
1. Macro의  replacement-list에는 다른 macro가 들어갈 수 있다.
>``` C
>#define PI 3.14
>#define PI_SQUARE (PI*PI)
>```

2. Preprocessor는 token이 통째로 독립적으로 있을 때만 replace한다. 문자열이나, 상수나, 그런 곳에 embedded된 부분은 대체하지 않는다.
>``` C
>#define print 5555
>int main()
>{
>   printf("%d %s", print, "print");
>}
>```

위 코드에서 정의된 macro는 `print`라는 토큰을 `5555`로 대체할텐데, 코드에서 `printf`의 일부분인 print나, `"print"`의 일부분인 print를 5555로 대체하지는 않는다. 오직 통째로 token인 %d에 해당하는 print만 5555로 대체되어서, `5555 print`라는 출력을 하게 된다.
3. Macro는 선언된 이후, 파일 끝까지 쭉 적용된다. 해제하기 위해서는
>``` C
>#undef identifiet
>```

를 사용하면 된다.
4. 매크로는 다르게 두 번 선언될 수 없다. 이때 '다르다'는 것은 공백이나 이런 형식적인 것 말고, token이나 parameter이나 replacement-list가 다른 경우를 말한다.
