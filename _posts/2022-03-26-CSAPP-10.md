---
title : Chapter 10. System-Level I/O
categories : 
  - C
tags :
  - C
last_modified_at: 2022-03-26T20:39:00-05:00
---
# Computer Systems : A Programmer's Perspective

I/O란 메인 메모리와 외부 장치들(디스크, 터미널, 네트워크 등) 간에 데이터가 복사되는 과정이다. Input은 I/O 장치에서 메인 메모리로 데이터를 복사해 오는 과정이고, output은 
메인 메모리에서 I/O 장치로 데이터를 복사해 가는 과정이다.<br />
모든 언어에서 run-time system은 입출력을 위한 high-level의 기능들을 제공한다. ANSI C에서는 표준 라이브러리가 우리에게 익숙한 `printf`, `scanf`같은 함수를 제공하고, C++에서는
`<<`, `>>` operator가 그 기능을 한다. 리눅스의 high-level 입출력 함수들은 리눅스 커널이 제공하는 Unix I/O 함수로 구현되어있다. 웬만하면 이 high-level 입출력 함수를 사용하면
문제가 없지만, 그럼에도 Unix I/O 함수를 배우는 이유는 다음과 같다.

- Unix I/O 함수를 이해하는 것은 전반적인 시스템의 개념을 이해하는 데 도움이 된다. 입출력은 시스템의 동작에 필수적이고, 종종 우리는 입출력과 다른 system idea 간에 순환 의존 관계를
마주하게 될 때가 있다. 예를 들어, 입출력은 프로세스의 생성과 실행에 중요한 역할을 하고 반대로 프로세스 생성은 파일이 다른 프로세스들에게 공유되는 것에 중요한 역할을 한다.
따라서 입출력을 이해하기 위해서는 프로세스를 이해해야 하고, 반대로 프로세스를 이해하기 위해서는 입출력을 이해해야 한다.
- Unix I/O 함수를 어쩔 수 없이 사용해야 될 때가 있다. 파일 metadata에 접근해야 할 때나, 네트워크 프로그래밍에서 표준 라이브러리의 입출력 함수를 쓰는 게 위험할 때가 있다.

이 챕터에서는 Unix I/O와 표준 I/O의 일반적인 개념과 안전한 사용법을 소개한다. 추후 네트워크 프로그래밍과 concurrency를 위한 기반이 되는 부분이다.

## 10.1 Unix I/O
리눅스에서 _file_ 은 byte의 sequence이다.<br />
모든 입출력 장치는 파일로 모델링되고, 모든 입력과 출력은 파일에 데이터를 쓰고 파일을 읽는 것으로 실행된다. 이 방법은 리눅스 커널이 일관된 방법으로 입출력을 수행할 수 있는
Unix I/O라는 단순한 low-level application 인터페이스를 제공할 수 있게 해 준다.
- Opening files : 응용 프로그램은 커널에게 파일의 _open_ 을 요청해서, 해당 입출력 장치에 접근할 것임을 알린다. 그러면 커널은 _descriptor_ 라고 하는 음이 아닌 정수를 반환해 주는데, 이는 앞으로 모든 파일에 대한 작업에서 그 파일을 식별하는 데 사용된다. 커널은 open file의 모든 정보를 추적하고 프로그램은 오직 이 descriptor만 가지고 있게 된다. <br /> 리눅스 쉘에 의해 생성된 모든 프로세스는 3개의 open file _standard input_ (0번), _standard output_ (1번), 그리고 _standard error_ (2번)을 기본적으로 가지고 시작한다. 이들의 descriptor는 `<unistd.h>`에서 매크로 `STDIN_FILENO`, `STDOUT_FILENO`, `STDERR_FILENO`로 정의가 되어 있다.
- Changing the current file position : 커널은 _file position_ k의 값을 관리하는데, 처음에는 모든 open file이 0이다. 파일의 시작부터의 offset을 뜻하며, 응용 프로그램은 파일의 position k를 _seek_ 함수를 통해 바꿀 수 있다.
- Reading and writing files : _read_ 함수는 파일에서 position k로부터 n>0 개 바이트를 메모리로 복사해 온다. 이때 k는 k+n이 된다. 만약 m바이트 파일에서 k>=m이 되면 _end-of-file(EOF)_ 가 발동되고, 프로그램은 이를 감지할 수 있다. 파일의 마지막에 따로 "EOF character"가 있는 것은 아니다.<br /> 비슷하게 _write_ 함수는 파일의 position k부터 n>0 바이트를 수정한다. 동일하게 k의 값도 바뀌게 된다.
- Closing files : 프로그램이 파일로의 접근을 끝마칠 때 커널에게 _close_ 를 요청해서 이를 알린다. 커널은 파일이 열려 있는 동안 생성했던 각종 자료구조들을 free하고 그 파일의 descriptor를 사용 가능한 descriptor로 되돌려 놓는다(다른 파일에게 할당될 수 있도록). 프로세스가 어떤 이유에서든 끝나면 커널은 모든 open file을 close하고 memory resource를 free한다.

## 10.2 Files
매 리눅스 파일은 시스템에서의 역할을 알려 주는 _type_ 을 갖는다.
- _regular_ 파일은 임의의 데이터를 담는 파일이다. 텍스트 파일이기도 하고, 프로그램의 소스 코드나 바이너리 파일일 수도 있다. 커널에게는 구분 없이 그냥 sequence of byte이다.<br /> 리눅스 텍스트 파일은 _text line_ 의 나열로 구성되는데, 각 _line_ 은 `'\n'`로 끝난다. 
- _directory_ 파일은 _link_ 의 배열로 구성되어 있고, 각 _link_ 는 파일과 그 파일명을 map시킨다. 모든 directory에는 적어도 두 개의 원소가 있는데, `.` 은 그 directory 자신을 의미하고 `..`은 부모 directory를 의미한다. `mkdir` 명령어로 디렉토리를 만들 수 있고 `ls`로 내용물을 볼 수 있으며 `rmdir`로 제거할 수 있다.
- _socket_ 은 네트워크를 통해 다른 프로세스와 통신하기 위해 사용되는 파일이다.

이 외에도 _named pipes_, _symbolic links_, _character_, _block devices_ 등등이 있다.<br />
리눅스 커널은 모든 파일을 하나의 _directory hierarchy_ 에서 관리하는데, `/`라는 이름의 root 디렉토리에서 시작한다. <br />
각 프로세스는 _current working directory_ 를 가지는데, 이는 디렉토리 계층 구조에서 현재 위치를 나타낸다. 쉘의 current working directory는 익숙한 `cd` 명령어로 바꿀 수 있다.<br />
디렉토리 계층 구조에서의 위치는 _pathname_ 으로 특정된다. 파일명과 `/`의 나열로 된 문자열로 되어 있고 두 가지 형태가 있다.
- 절대 경로(absolute pathname)은 `/`, 즉 root에서 시작한다.
- 상대 경로(relative pathname)은 현재 작업 중인 디렉토리에서 시작한다. 현재 작업 중인 디렉토리가 `/home/droh`이면 `hello.c`의 상대 경로는 `./hello.c`가 되고, 현재 작업 중인 디렉토리가 `/home/bryant`이면 상대 경로는 `../home/droh/hello.c`가 된다.

## 10.3 Opening and Closing Files
프로세스는 아래 함수를 이용해서 새 파일을 만들거나, 기존 파일을 열 수 있다.
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcnt1.h>
int open(char *filename, int flags, mode_t mode);
```
이 함수는 `filename`을 file descriptor로 변환해서 이를 반환해 준다. 배정되는 값은 현재 해당 프로세스에서 열려 있지 않은 file descriptor 중 가장 작은 값이다.<br />
`flag`는 프로세스가 파일을 어떻게 접근하고자 하는지를 정한다. 
- O_RDONLY 는 읽기 전용
- O_WRONLY 는 쓰기 전용
- O_RDWR 은 읽기 및 쓰기c

`flag`는 or 연산을 통해서 쓰기 관련해서 추가적인 설정을 할 수 있다.
- O_CREAT 를 설정하면, 파일이 존재하지 않을 때 빈 파일을 생성한다.
- O_TRUNC 를 설정하면, 파일이 존재하지 않을 때 빈 파일로 덮어씌운다.
- O_APPEND 를 설정하면, 파일에 write 를 하기 전에 항상 file position을 파일의 끝으로 설정한다.

`mode`는 새 파일에 대한 접근 권한을 명시하는 부분이다. 교과서의 Figure 10.2에 종류가 나와 있다.<br />
프로세스는 context 중 하나로 `umask` 함수로 설정할 수 있는 _umask_ 를 가진다. 프로세스가 _open_ 으로 파일을 열 때 mode 인자를 넣어 주면, 그 파일의 접근 권한은 `mode & ~umask` 로 설정된다.<br />
마지막으로, 프로세스는 `close` 함수를 이용해서 open file을 닫을 수 있다. 
```c
#include <unistd.h>
int close(int fd);
```
이미 닫았거나 없는 file descriptor를 쓰면 에러가 발생하고 -1을 반환하고, 이상이 없으면 0을 반환한다.

## 10.4 Reading and Writing Files
프로그램은 _read_, _write_ 함수를 이용해서 입력과 출력을 할 수 있다.
```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
```
`read` 함수는 `fd`에 해당하는 파일의 current file position으로부터 최대 `n`바이트를 `buf`에 복사한다. 에러가 발생하면 반환값은 -1이고, EOF이면 0이다. 정상적으로 수행된 경우는 실제로 전해진 바이트 수가 반환된다.<br />
`write` 함수는 `buf`의 최대 `n`바이트를 복사해서 `fd`에 해당하는 파일의 current file position부터로 복사한다. `lseek` 함수는 프로그램이 명시적으로 file position을 수정할 수 있게 해 준다.<br />
어떤 상황에서는 `read`와 `write`에서 프로그램이 요청한 바이트 수보다 적은 바이트가 전달될 때가 있다. 이를 _short count_ 라고 하며, 이는 에러라고 하지 않는다. 발생할 수 있는 이유는 여러 가지가 있다.
- Entering EOF on reads : 20바이트 짜리 파일에서 50바이트를 읽으려고 하면, 요청한 50보다 적은 20바이트만 복사되고 short count가 발생한다. _read_ 는 0을 반환해서 EOF가 났음을 알린다.
- Reading text lines from a terminal : open file이 터미널 같은 것이면, 매 `read` 함수는 `'\n'`으로 끊기는 text line만큼만 읽게 된다.
- Reading and writing network sockets : open file이 네트워크 소켓이면, 내부 버퍼의 한계나 긴 딜레이로 인해 short count가 나타날 수 있다.

보통은 디스크에서 `read`할 때는 EOF를 만날 일이 없고, `write`도 동일하다. 하지만 웹 서버와 같은 네트워크 application을 robust하게 만들고자 한다면, 요청한 모든 바이트가 도착할 때까지 반복적해서 `read`나 `write`를 요쳥해 줘야 한다.

## 10.5 Robust Reading and Writing with the _RIO_ Package
이 절에서는 자동으로 short count를 처리해 주는 RIO(Robust I/O) 패키지를 다룬다. RIO는 두 종류의 함수를 제공한다.
- Unbuffered I/O function: 메모리와 파일 간에 데이터를 buffer 없이 직접 전달한다. 네트워크에서 binary data를 주고받을 때 특히 유용하다.
- Buffered input function: Application 단계에 있는 buffer를 이용해서 text line이나 binary data를 효율적으로 읽을 수 있게 한다. 표준 라이브러리의 printf와 비슷하다. 

### 10.5.1 _RIO_ Unbuffered Input and Output Function
`rio_readn`과 `rio_writen`은 Unix의 `read`와 `write`와 비슷하다. 대신, `rio_readn`은 EOF일 때만 short count가 날 수 있고 다른 경우에는 나지 않는다. `rio_writen`은 어떤 경우에도 short count가 나지 않는다. 
