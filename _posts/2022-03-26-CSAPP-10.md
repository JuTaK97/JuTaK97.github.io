---
title : Chapter 10. System-Level I/O
categories : 
  - C
tags :
  - C
last_modified_at: 2022-03-26T20:39:00-05:00
---
# Computer Systems : A Programmer's Perspective

I/O란 메인 메모리와 외부 장치들(디스크, 터미널, 네트워크 등) 간에 데이터가 복사되는 과정이다. Input은 I/O 장치에서 메인 메모리로 데이터를 복사해 오는 과정이고, output은 
메인 메모리에서 I/O 장치로 데이터를 복사해 가는 과정이다.<br />
모든 언어에서 run-time system은 입출력을 위한 high-level의 기능들을 제공한다. ANSI C에서는 표준 라이브러리가 우리에게 익숙한 `printf`, `scanf`같은 함수를 제공하고, C++에서는
`<<`, `>>` operator가 그 기능을 한다. 리눅스의 high-level 입출력 함수들은 리눅스 커널이 제공하는 Unix I/O 함수로 구현되어있다. 웬만하면 이 high-level 입출력 함수를 사용하면
문제가 없지만, 그럼에도 Unix I/O 함수를 배우는 이유는 다음과 같다.

- Unix I/O 함수를 이해하는 것은 전반적인 시스템의 개념을 이해하는 데 도움이 된다. 입출력은 시스템의 동작에 필수적이고, 종종 우리는 입출력과 다른 system idea 간에 순환 의존 관계를
마주하게 될 때가 있다. 예를 들어, 입출력은 프로세스의 생성과 실행에 중요한 역할을 하고 반대로 프로세스 생성은 파일이 다른 프로세스들에게 공유되는 것에 중요한 역할을 한다.
따라서 입출력을 이해하기 위해서는 프로세스를 이해해야 하고, 반대로 프로세스를 이해하기 위해서는 입출력을 이해해야 한다.
- Unix I/O 함수를 어쩔 수 없이 사용해야 될 때가 있다. 파일 metadata에 접근해야 할 때나, 네트워크 프로그래밍에서 표준 라이브러리의 입출력 함수를 쓰는 게 위험할 때가 있다.

이 챕터에서는 Unix I/O와 표준 I/O의 일반적인 개념과 안전한 사용법을 소개한다. 추후 네트워크 프로그래밍과 concurrency를 위한 기반이 되는 부분이다.

## 10.1 Unix I/O
리눅스에서 _file_ 은 byte의 sequence이다.<br />
모든 입출력 장치는 파일로 모델링되고, 모든 입력과 출력은 파일에 데이터를 쓰고 파일을 읽는 것으로 실행된다. 이 방법은 리눅스 커널이 일관된 방법으로 입출력을 수행할 수 있는
Unix I/O라는 단순한 low-level application 인터페이스를 제공할 수 있게 해 준다.
- Opening files : 응용 프로그램은 커널에게 파일의 _open_ 을 요청해서, 해당 입출력 장치에 접근할 것임을 알린다. 그러면 커널은 _descriptor_ 라고 하는 음이 아닌 정수를 반환해 주는데, 이는 앞으로 모든 파일에 대한 작업에서 그 파일을 식별하는 데 사용된다. 커널은 open file의 모든 정보를 추적하고 프로그램은 오직 이 descriptor만 가지고 있게 된다. <br /> 리눅스 쉘에 의해 생성된 모든 프로세스는 3개의 open file _standard input_ (0번), _standard output_ (1번), 그리고 _standard error_ (2번)을 기본적으로 가지고 시작한다. 이들의 descriptor는 `<unistd.h>`에서 매크로 `STDIN_FILENO`, `STDOUT_FILENO`, `STDERR_FILENO`로 정의가 되어 있다.
- Changing the current file position : 커널은 _file position_ k의 값을 관리하는데, 처음에는 모든 open file이 0이다. 파일의 시작부터의 offset을 뜻하며, 응용 프로그램은 파일의 position k를 _seek_ 함수를 통해 바꿀 수 있다.
- Reading and writing files : _read_ 함수는 파일에서 position k로부터 n>0 개 바이트를 메모리로 복사해 온다. 이때 k는 k+n이 된다. 만약 m바이트 파일에서 k>=m이 되면 _end-of-file(EOF)_ 가 발동되고, 프로그램은 이를 감지할 수 있다. 파일의 마지막에 따로 "EOF character"가 있는 것은 아니다.<br /> 비슷하게 _write_ 함수는 파일의 position k부터 n>0 바이트를 수정한다. 동일하게 k의 값도 바뀌게 된다.
- Closing files : 프로그램이 파일로의 접근을 끝마칠 때 커널에게 _close_ 를 요청해서 이를 알린다. 커널은 파일이 열려 있는 동안 생성했던 각종 자료구조들을 free하고 그 파일의 descriptor를 사용 가능한 descriptor로 되돌려 놓는다(다른 파일에게 할당될 수 있도록). 프로세스가 어떤 이유에서든 끝나면 커널은 모든 open file을 close하고 memory resource를 free한다.

## 10.2 Files
매 리눅스 파일은 시스템에서의 역할을 알려 주는 _type_ 을 갖는다.
- _regular_ 파일은 임의의 데이터를 담는 파일이다. 텍스트 파일이기도 하고, 프로그램의 소스 코드나 바이너리 파일일 수도 있다. 커널에게는 구분 없이 그냥 sequence of byte이다.<br /> 리눅스 텍스트 파일은 _text line_ 의 나열로 구성되는데, 각 _line_ 은 `'\n'`로 끝난다. 
- _directory_ 파일은 _link_ 의 배열로 구성되어 있고, 각 _link_ 는 파일과 그 파일명을 map시킨다. 모든 directory에는 적어도 두 개의 원소가 있는데, `.` 은 그 directory 자신을 의미하고 `..`은 부모 directory를 의미한다. `mkdir` 명령어로 디렉토리를 만들 수 있고 `ls`로 내용물을 볼 수 있으며 `rmdir`로 제거할 수 있다.
- _socket_ 은 네트워크를 통해 다른 프로세스와 통신하기 위해 사용되는 파일이다.

