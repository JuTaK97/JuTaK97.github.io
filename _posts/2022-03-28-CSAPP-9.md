---
title : Chapter 9. Virtual Memory
categories : 
  - C
tags :
  - C
last_modified_at: 2022-03-28T20:08:00-05:00
---
# Computer Systems : A Programmer's Perspective (CSAPP)
<br /><br />
시스템의 프로세스들은 다른 프로세스들과 CPU와 메인 메모리를 공유한다. 하지만 메인 메모리를 나눠 쓰려면 해결해야 할 문제가 있다. CPU의 부하가 늘면 프로세스는 점점 느려지고, 너무 많은 프로세스가 너무 많은 메모리를 요구하면 일부 프로세스는 작동하지 못하게 된다. 또한 메모리는 오염(corruption)에 취약하다. 어떤 프로세스가 실수로 다른 프로세스가 사용하는 메모리를 수정해버리면 그 프로세스는 자신의 프로그램과 전혀 관계 없는 이유로 정상적인 동작에 실패하게 된다.<br />
메모리를 효율적으로 관리하고 에러를 줄이기 위해 현대 컴퓨터 시스템은 _virtual memory_ 라는 메인 메모리의 추상적인 개념을 제공한다. 가상 메모리는 hardware exception, hardware address translation, 메인 메모리, 디스크 파일, 커널 소프트웨어의 명쾌하고 멋진 상호작용으로, 각 프로세스에게 넓고 일관된 자신만의 주소 공간(address space)를 제공한다. 가상 메모리라는 매커니즘 하나만으로 세 가지를 제공한다 : 
1. 메인 메모리를 마치 디스크의 캐시(cache)로 취급해서 효율적으로 사용한다. 메인 메모리에는 사용 중인(active) 것만 저장하고 필요할 때마다 디스크와 메모리 간에 데이터를 주고받는다.
2. 각 프로세스에게 동일한 주소 공간을 제공해서 메모리 관리를 단순화한다.
3. 각 프로세스의 주소 공간을 개인화함으로써 다른 프로세스에 의해 오염되는 것을 방지한다.

가상 메모리는 컴퓨터 시스템에서 가장 위대한 아이디어 중 하나이다. 조용하게 자동으로 작동하고, 응용 프로그램의 프로그래머의 간섭 없이 잘 작동한다. 무대 뒤에서 알아서 잘 일해주는데 왜 프로그래머가 그것을 이해해야 하는가? 여러 가지 이유가 있다.
- **가상 메모리는 핵심이다.**<br />가상 메모리는 컴퓨터의 모든 레벨에 녹아들어 있고 hardware exception, 어셈블러, 링커, loader, shared object, 파일, 프로세스의 디자인에서 핵심적인 역할을 한다. 가상 메모리를 이해해야 시스템이 돌아가는 것을 더 잘 이해할 수 있다.<br />
- **가상 메모리는 강력하다.**<br />가상 메모리는 응용 프로그램이 메모리를 생성 및 소멸시키고, 디스크의 파일과 메모리를 짝짓고(map), 다른 프로세스들과 메모리를 공유할 수 있는 강력한 도구가 된다. 예를 들어, 당신은 디스크 파일의 내용물을 단지 메모리의 어떤 곳을 읽고 쓰는 것으로 수정할 수 있다는 것을 알고 있었는가? 또, 명시적인 복사 없이도 메모리에 파일의 내용물을 로드해 올 수 있다는 것을 알고 있었는가? 가상 메모리를 이해하는 것은 당신의 응용 프로그램이 이러한 강력한 기능을 이용할 수 있도록 해 준다.<br />
- **가상 메모리는 위험하다.**<br />응용 프로그램은 변수를 참조하고, 포인터를 역참조하고(주: 포인터 앞에 asterisk를 붙여서 해당 주소의 값을 읽는 것.), `malloc`과 같은 동적 할당 함수를 사용할 때마다 가상 메모리와 상호작용한다. 가상 메모리를 부적절하게 사용하면 응용 프로그램은 모르는 사이에 무척 복잡한 메모리 관련 버그로 고통받게 된다. 다들 한번쯤은 segmentation fault, protection fault로 프로그램이 즉시 종료된 경험은 있을 것이고, 수 시간동안 문제 없이 돌아가다가 프로그램이 터지기도 하고 더욱 공포스러운 경우는 문제 없이 다 돌아갔는데 결과만 틀릴 때도 있다. 가상 메모리를 잘 이해하고, `malloc`과 같은 가상 메모리를 이용하는 함수를 잘 이해해야 이런 에러를 피할 수 있을 것이다.<br />

이 장에서는 가상 메모리를 두 가지 각도에서 바라본다. 전반부에서는 가상 메모리가 어떻게 동작하는지 살펴본다. 후반부에서는 응용 프로그램이 가상 메모리를 어떻게 사용하고 관리하는지 살펴본다. 가상 메모리가 무척 복잡하다는 사실을 회피하지는 않을 것이고, 곳곳에서 이에 대한 디스커션을 통해 고찰할 것이다. 좋은 소식은, 당신이 이런 세부적인 부분을 모두 잘 익힌다면 직접 조그만 가상 메모리 매커니즘을 만들어 볼 수 있을 것다. 그러면 가상 메모리라는 아이디어는 더이상 신비 속의 존재가 아니게 될 것이다.

## 9.1 Physical and Virtual Addressing
컴퓨터에서 메인 메모리는 M개의 연속된 byte-size cell의 배열로 짜여 있다. 각 바이트는 고유한 _physical address_ (PA)를 가진다. 이런 단순한 구성에서, CPU가 메인 메모리에 접근하는 가장 자연스로운 방법은 이 PA를 사용하는 것이다. 우리는 이런 접근 방법을 _physical addressing_ 이라고 부른다. Physical address 4부터 시작해서 4바이트를 읽어 오라는 load instruction이 수행되는 과정은 먼저 CPU가 memory bus로 물리 주소 4를 메모리에게 전달하고, 메인 메모리는 이를 받아서 물리 주소 4부터 4-바이트의 word를 fetch해서 CPU에게 보내주고, CPU는 이를 레지스터에 저장하게 된다.<br />
초기의 컴퓨터는 이러한 physical addressing을 사용했고, 임베디드 마이크로컨트롤러나 디지털 신호 프로세서는 아직 이런 방식을 사용한다. 하지만 현대적인 프로세서는 이 방식이 아닌, _virtual addressing_ 이라는 방식을 사용한다.
![image](https://user-images.githubusercontent.com/88367636/160392762-a78a956e-74fe-42cb-ab99-08632974cd4c.png)
위 그림은 virtual addressing을 나타낸 그림이다. CPU는 물리 주소로 메모리에 접근하지 않고, _virtual address_ (VA, 가상 주소)를 이용해 접근하게 된다. 가상 주소는 메모리에 가기 전에 적절한 물리 주소로 변환된다. 이런 변환 작업을 _address translation_ 이라고 부르고, exception handling 때처럼 CPU 하드웨어와 운영 체제의 밀접한 협동을 필요로 한다. CPU 하드웨어 칩에서 _memory management unit_ (MMU)라는 부분이 이를 전담하며, 운영체제가 내용을 관리하는 메모리의 lookup table을 보고 가상 주소에서 물리 주소로 변환해 준다.

## 9.2 Address Spaces
