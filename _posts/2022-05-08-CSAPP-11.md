---
title : Chapter 11. Networks
categories : 
  - C
use_math : true
comments : true
tags :
  - C
last_modified_at: 2022-05-8T21:08:00-05:00
---
# Computer Systems : A Programmer's Perspective (CSAPP)
<br /><br />
## 11.1 The Client-Server Programming Model

모든 네트워크 응용 프로그램은 _client-server model_ 에 기반한다. 이 모델에서 응용 프로그램은 한 개의 **서버** 프로세스와 여러 개의 **클라이언트** 프로세스로 구성된다. 
서버는 **리소스**를 잘 관리해서 클라이언트에게 **서비스**를 제공한다. 예를 들어 FTP 서버는 클라이언트를 위해 디스크 파일들을 저장하고 검색한다. <br />

클라이언트-서버 모델의 가장 기본적인 동작은 _transaction_ 이다. 
![image](https://user-images.githubusercontent.com/88367636/167296764-5d62ad2a-3e85-439a-881e-fa319f301c3d.png)

다음 4개 단계로 구성된다.
1. 클라이언트는 서비스가 필요할 때 서버에게 request를 보내서 transaction을 개시한다. 예를 들면 웹 브라우저가 파일이 필요하면 웹 서버에게 요청을 보낸다.
2. 서버가 요청을 받으면 그걸 해석한 후 적절하게 리소스를 처리한다. 예를 들면 웹 서버는 브라우저의 요청을 받고 저장하고 있는 디스크 파일을 읽는다.
3. 서버는 클라이언트에게 response를 보내고 다음 request를 기다린다. 
4. 마지막으로, response를 받은 클라이언트는 그걸 잘 처리한다. 예를 들면 웹 브라우저는 서버의 응답을 받아서 웹 페이지로 만들어 화면에 띄운다.

<br />
여기서 말하는 클라이언트와 서버는 프로세스이지, 기계나 흔히 말하는 호스트가 아니라는 사실에 주목해야 한다. 하나의 호스트는 여러 개의 클라이언트와 서버를 동시에 실행시킬 수 있고, 클라이언트와 서버 간의 transaction도 같은 host 내에서 이뤄질 수도 있고 다른 host 간에 일어날 수도 있다. 

## 11.2 Networks
클라이언트와 서버는 주로 별개의 호스트에서 실행되어 _computer network_ 라고 불리는 하드웨어/소프트웨어 리소스를 이용해 통신한다. 네트워크는 무척 복잡한 시스템으로, 여기에서는 개략적으로만 다룬다다. 현재의 목표는 프로그래머의 관점에서 적당한 멘탈 모델(심성 모델)만 제공하는 것이다.<br />

호스트 입장에서 네트워크는 데이터의 source와 sink의 역할을 하는 그냥 또 하나의 입출력 장치이다. 
![image](https://user-images.githubusercontent.com/88367636/167297192-85f9cf4b-f8e1-4dfc-9a5c-7faee4f578ad.png)
 
 위 그림을 보면, 기존의 I/O bus에 추가적으로 달린 슬롯이 있고 그곳을 통해 네트워크와의 물리적인 인터페이스가 제공된다. 네트웨크에서 들어온 데이터는 어댑터에서 복사되어 I/O bus와 memory bus를 타고 전달된다. 반대 방향도 비슷하게 메모리에서 네트워크로 데이터가 복사될 수 있다.<br />
 
 물리적으로, 네트워크는 지리적 근접성으로 구성된 계층적인 시스템이다. 가장 낮은 레벨은 LAN으로, LAN의 범위는 한 건물 혹은 한 캠퍼스 정도이다. 가장 보편적인 LAN 기술은 1970년대에 개발된 우리에게 익숙한 Ethernet이다.<br />
Ethernet segment는 하나의 허브와 회선(주로 twisted pair)로 구성되어 있다. 한 이더넷 세그먼트는 건물의 한 층이나 하나의 방 정도를 커버한다. 각 회선은 동일한 최대 비트 대역폭(주로 100Mb/s나 1Gb/s)를 갖는다. 한쪽 끝은 호스트의 어댑터에, 반대쪽 끝은 허브에 있는 port에 연결되어 있다. 허브는 각 포트를 통해 들어온 비트들을 모든 다른 포트로 단순하게 복사한다. 즉, 모든 호스트들은 허브를 거치는 모든 비트를 볼 수 있다.<br />

각 이더넷 어댑터들은 각자의 비휘발성 메모리에 저장된 고유의 48비트 주소가 있다. 호스트가 같은 구역의 다른 호스트에게 보내는 비트는 frame이라고 하는데, 각 프레임은 _header_ 라고 부르는 고정된 길이의 비트가 있다. 프레임 헤더에는 프레임의 src외 dst를 구분할 수 있는 정보와 프레임의 길이가 담겨 있고, 헤더 다음에 프레임의 진짜 내용(payload)가 붙어 있다. 각 호스트의 어댑터는 프레임을 볼 수 있지만 실제로 해당 프레임을 읽는 것은 종착지(dst)의 호스트가 된다.<br />

여러 개의 이더넷 구역(segment)들은 더 커다란 LAN으로 연결될 수 있고 이를 bridged Ethernet이라고 한다. 다음 그림과 같이 bridge라고 불리는 작은 박스와 여러 회선들을 사용해서 이를 만든다.
![image](https://user-images.githubusercontent.com/88367636/167298509-5468745b-447a-4728-b341-23de80c2660e.png)

Bridged LAN은 이제 건물 전체나 캠퍼스 전체를 커버할 수 있다. 브릿지 간에 연결된 회선도 있고 브릿지와 허브 간에 연결된 회선도 있는데 회선들의 대역폭은 각각 다를 수 있다. 위 그림에서는 브릿지 간 회선은 1Gb/s의 대역폭을 가지고 4개의 허브-브릿지 회선은 100Mb/s의 대역폭을 갖는다.<br />

브릿지는 회선의 대역폭을 허브보다 더 효율적으로 사용한다. 알고리즘을 통해서 어떤 포트로 보내야 어떤 호스트에게 닿을 수 있는지를 시간이 지나며 자동으로 배워 가고, 포트 간에 프레임을 복사할 때 딱 필요한 것만 선별적으로 복사한다. 예를 들어 위 그림의 호스트 A가 B에게 프레임을 보내면 이 둘은 같은 구역에 있기 때문에 브릿지 X는 이 프레임을 봐도 그 너머로 복사하지 않고 버려서 다른 구역이 대역폭을 절약할 수 있게 한다. 만약 호스트 A가 C에게 프레임을 보낸다면, 브릿지 X는 이번에는 프레임을 복사해서 Y에게 전달하게 되고 Y는 C가 있는 구역으로 가는 포트에만 프레임을 복사할 것이다.<br />

이제 더 높은 곳에서 살펴보기 위해 LAN을 간략화한다. 이제 허브, 브릿지, 그리고 회선들은 뭉뚱그려서 아래 그림과 같은 수평의 선으로 표시한다. 
![image](https://user-images.githubusercontent.com/88367636/167299121-d863c1bc-e619-4222-8d0f-24aef8aff1f9.png)

계층 구조에서 한 칸 위로 올라간다. <br />
여러 개의 호환되지 않는 LAN들은 router라고 불리는 특별한 컴퓨터를 통해 상호 연결되어서 인터넷(internet, 고유명사 아님)을 구성한다. 각 라우터는 연결된 각 네트워크를 위한 어댑터(포트)가 있다. <br />
라우터는 고속의 point-to-point 전화선들을 연결하기도 하는데, 이는 WAN이라고 부르는 LAN보다 광범위한 영역에 걸쳐 있는 네트워크의 예시 중 하나이다.<br />
일반적으로 라우터는 임의의 LAN들과 WAN들 간의 internet(역시 고유명사 아님)을 구축하는데 사용된다. 아래 그림에서는 두 개의 LAN과 WAN들이 3개의 라우터를 통해 연결되어 있다.
![image](https://user-images.githubusercontent.com/88367636/167299322-e625290d-b5a6-49ec-812c-5ee4da009859.png)

인터넷의 가장 중요한 특성은, 근본적으로 다르고 호환되지 않는 기술을 쓰는 여러 LAN과 WAN들로 구성된다는 것이다. 호스트가 물리적으로 다른 호스트와 연결되어 있다고 해도 어떻게 source host에서 destination host까지 이 모든 호환 불가능한 네트워크들을 거쳐서 비트를 주고받을 수 있을까?<br />

해답은 각 호스트와 라우터에서 네트워크 간의 차이를 없애기 위해 실행하는 _protocol software_ 계층이다. 이 소프트웨어는 호스트와 라우터가 데이터를 잘 전송하기 위해 서로 어떻게 협동해야 하는지를 관장하는 프로토콜을 실행한다. 프로토콜은 두가지 기본적인 기능이 있다.<br />
- Naming Schemes <br /> 서로 다른 LAN 기술들은 호스트에게 주소를 부여하는 각자의 방법을 가지고 있고, 이는 다른 네트워크와 호환되지 않는다. 따라서 인터넷 프로토콜은 이런 차이를 없애기 위해 호스트 주소를 고유의 포맷으로 정의한다. 각 호스트는 고유하게 식별될 수 있는 internet address를 적어도 한 개 할당받게 된다.
- Delivery mechanism<br /> 서로 다른 네트워킹 기술들은 회선을 따라 흐르는 비트를 인코딩하는 방법도 서로 다르고 비트를 프레임으로 포장하는 방식도 달라서 서로 호환되지 않는다. 인터넷 프로토콜은 이 차이를 없애기 위해서 데이터의 비트들을 모아서 덩어리로 만들 수 있는 packet이라는 일관된 방식을 정의한다. 패킷은 출발/도착 호스트와 패킷의 크기 정보들 담은 헤더와 실제 데이터 비트인 payload로 구성된다.

<br />
아래 그림은 호스트들과 라우터들이 호환되지 않는 LAN 간에 데이터를 주고받기 위해 인터넷 프로토콜을 어떻게 사용하는지를 보여준다.
![image](https://user-images.githubusercontent.com/88367636/167299933-f76208e6-9077-46d3-9db3-75a4852f01b2.png)

1. 호스트 A의 클라이언트(=프로세스)는 가상 메모리 공간에서 커널의 버퍼로 데이터를 복사하는 시스템 콜을 요청한다.
2. 호스트 A의 프로토콜 소프트웨어는 인터넷 헤더와 LAN1식 프레임 헤더를 붙여서 LAN1 프레임을 만든다. 인터넷 헤더에는 전체 네트워크에서 종착지인 호스트 B의 인터넷 주소가 담겨 있고, LAN1 프레임 헤더에는 LAN1 내에서의 종착지인 라우터(그림의 가운데)로의 주소가 담겨 있다. 이렇게 만들어진 프레임은 호스트 A의 LAN1 어댑터로 전달된다. 이때 전달되는 데이터는 두 단계로 encapsulation되어 있고 이것이 internetworking의 근본적인 개념이 된다.
3. 호스트 A의 LAN1 어댑터는 프레임을 네트워크에 복사한다.
4. LAN1 프레임 헤더의 정보를 이용해서 무사히 라우터에 도달하면, 라우터의 LAN1 어댑터는 이를 읽어온 후 프로토콜 소프트웨어에게 전달한다.
5. 라우터는 인터넷 패킷에서 도착지의 인터넷 주소를 얻고, 이것을 routing table의 인덱스로 사용해서 어느 쪽으로 패킷을 forwarding해야 할지 결정한다. 이 경우에는 LAN2 쪽으로 보내는 것으로 결정하게 되어 LAN1의 프레임 헤더를 떼고 LAN2의 프레임 헤더를 맨 앞에 붙여 LAN2 어댑터에게 전달한다. 인터넷 헤더에는 그대로 호스트 B의 주소가 담겨 있다.
6. 라우터의 LAN2 어댑터는 프레임을 네트워크에 복사한다.
7. 호스트 B에 도달하면 호스트 B의 LAN2 어댑터가 프레임을 읽고 프로토콜 소프트웨어에게 전달한다.
8. 마지막으로, 호스트 B의 프로토콜 소프트웨어는 패킷 헤더와 프레임 헤더를 제거하고 최종적으로 데이터(payload)를 B의 가상 주소공간에 복사한다. 그리고 서버는 이 데이터를 읽기 위한 시스템 콜을 요청한다.

이 과정 중에는 수많은 문제들이 있지만 우리는 그것들을 숨기고 있다. 서로 다른 네트워크의 최대 프레임 크기가 다르면 어떻게 할 것인지? 라우터는 프레임을 어디로 forwarding해야 할지 어떻게 아는지? 라우터는 네트워크의 topology가 바뀌면 이걸 어떻게 통보받는지? 패킷이 손실되면 어떻게 하는지? 등등의 문제가 있다.<br />

하지만 위의 예시는 단순히 인터넷이란 것의 근본적인 아이디어만 보여준 것이고, encapsulation의 개념만 알아가면 된다.

## 11.3 The Global IP Internet
 
  



