---
title : Chapter 8. Exceptional Control Flow (PART 2)
categories : 
  - C
tags :
  - C
last_modified_at: 2020-03-22T20:13:00-05:00
---
# Computer Systems : A Programmer's Perspective
8.1장부터 8.4장까지는 하드웨어와 소프트웨어가 협력해서 low-level exception을 제공하는 방식을 살펴보았다. 또한 운영체제가 context switch를 통해 exceptional control flow를
만들기 위해 exception을 사용하는 것을 살펴보았다. 이번 장에서는 좀 더 higher-level의 exception control flow인 Linux signal을 살펴본다. 
## 8.5 Signals
Process와 kernel이 다른 process를 interrupt하게 해 주는 _signal_ 은 일종의 작은 message로, 어떠한 종류의 event가 발생했음을 process에게 알리는 역할을 한다. 교과서 Fig 8.26에는
30종류의 Linux signal들이 나열되어 있다.<br />
각 signal 종류는 system event의 종류에 대응된다. Low-level의 hardware exception은 kernel의 exception handler에 의해 처리되고, 보통은 user process에게는 보이지 않는다. 
Signal은 이런 exception의 발생을 user process에게 알리는 역할을 한다. 예를 들어 어떤 process에서 0으로 나누려고 하면 kernel이 8번 signal인 SIGFPE를 보낸다. Illegal memory
reference를 하려 하면 kernel은 11번 SIGSEGV signal을 내보낸다.<br />
하드웨어적인 event 외에도 higher-level의 software event를 알리는 signal도 있다. 예를 들어 Ctrl+C를 누르면 kernel은 foreground에서 돌아가는 process들에게 2번 SIGINT signal을 
내보낸다. 다른 process를 강제로 종료시킬 수 있는 SIGKILL signal(9번)도 있고, child process가 terminate되거나 stop될 때 kernel이 parent에게 보내는 17번 SIGCHILD signal도 있다.
### 8.5.1 Signal Terminology
Signal의 전송은 두 단계로 구성된다.<br />
_Sending a signal_ <br />
Kernel은 destination process의 context의 어떤 state를 바꾸는 것으로 signal을 전달한다. Signal이 전송되는 이유는 두 가지가 있다.<br />
- Kernel이 0으로 나눈 에러나 child process의 종료 같은 system event를 감지했을 때
- Process가 _kill_ function을 불렀을 때<br />
process는 스스로에게 signal을 보낼 수도 있다.<br />

_receieving a signal_<br />

Destination process는 signal을 받으면 signal을 무시하거나(ignore), 프로세스를 종료하거나(terminate), signal handler라는 user-level function을 통해 _catch_ 한다.<br />
전송은 됐지만 received되지 않은 signal을 _pending signal_ 이라고 한다. 이때 중요한 것은 signal은 queue되지 않기 때문에 어느 시점에서 pending 상태인 같은 type의 signal은
하나밖에 없다는 것이다. 특정 type의 signal이 pending 중이라면, 그때 또 도착한 해당 type의 signal은 버려진다.<br />
Process는 선별적으로 특정 signal의 수신을 _block_ 할 수 있다. 


