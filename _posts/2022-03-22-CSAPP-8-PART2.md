---
title : Chapter 8. Exceptional Control Flow (PART 2)
categories : 
  - C
tags :
  - C
last_modified_at: 2020-03-22T20:13:00-05:00
---
# Computer Systems : A Programmer's Perspective
8.1장부터 8.4장까지는 하드웨어와 소프트웨어가 협력해서 low-level exception을 제공하는 방식을 살펴보았다. 또한 운영체제가 context switch를 통해 exceptional control flow를
만들기 위해 exception을 사용하는 것을 살펴보았다. 이번 장에서는 좀 더 higher-level의 exception control flow인 Linux signal을 살펴본다. 
## 8.5 Signals
Process와 kernel이 다른 process를 interrupt하게 해 주는 _signal_ 은 일종의 작은 message로, 어떠한 종류의 event가 발생했음을 process에게 알리는 역할을 한다. 교과서 Fig 8.26에는
30종류의 Linux signal들이 나열되어 있다.<br />
각 signal 종류는 system event의 종류에 대응된다. Low-level의 hardware exception은 kernel의 exception handler에 의해 처리되고, 보통은 user process에게는 보이지 않는다. 
Signal은 이런 exception의 발생을 user process에게 알리는 역할을 한다. 예를 들어 어떤 process에서 0으로 나누려고 하면 kernel이 8번 signal인 SIGFPE를 보낸다. Illegal memory
reference를 하려 하면 kernel은 11번 SIGSEGV signal을 내보낸다.<br />
하드웨어적인 event 외에도 higher-level의 software event를 알리는 signal도 있다. 예를 들어 Ctrl+C를 누르면 kernel은 foreground에서 돌아가는 process들에게 2번 SIGINT signal을 
내보낸다. 다른 process를 강제로 종료시킬 수 있는 SIGKILL signal(9번)도 있고, child process가 terminate되거나 stop될 때 kernel이 parent에게 보내는 17번 SIGCHILD signal도 있다.
### 8.5.1 Signal Terminology
Signal의 전송은 두 단계로 구성된다.<br />
_Sending a signal_ <br />
Kernel은 destination process의 context의 어떤 state를 바꾸는 것으로 signal을 전달한다. Signal이 전송되는 이유는 두 가지가 있다.<br />
- Kernel이 0으로 나눈 에러나 child process의 종료 같은 system event를 감지했을 때
- Process가 _kill_ function을 불렀을 때<br />
process는 스스로에게 signal을 보낼 수도 있다.<br />

_receieving a signal_<br />

Destination process는 signal을 받으면 signal을 무시하거나(ignore), 프로세스를 종료하거나(terminate), signal handler라는 user-level function을 통해 _catch_ 한다.<br />
전송은 됐지만 received되지 않은 signal을 _pending signal_ 이라고 한다. 이때 중요한 것은 signal은 queue되지 않기 때문에 어느 시점에서 pending 상태인 같은 type의 signal은
하나밖에 없다는 것이다. 특정 type의 signal이 pending 중이라면, 그때 또 도착한 해당 type의 signal은 버려진다.<br />
Process는 선별적으로 특정 signal의 수신을 _block_ 할 수 있다. Block된 signal은 전달은 되지만, pending signal이 되어서 process가 unblock하기 전까지 receive되지 않는다.

### 8.5.2 Sending Signals
Unix는 process에게 signal을 보내기 위한 많은 방법들을 제공하는데, 모든 매커니즘들은 _process group_ 이라는 개념에 의존한다.

#### Process Groups
모든 process는 딱 하나의 _process group_ 에 속하고, 양의 정수인 _process group ID_ 로 식별할 수 있다. 아래 함수는 현재 process의 _process group ID_ 를 반환한다.
```c
#include <unistd.h>
pid_t getpgrp(void);
```
기본적으로 child process는 parent와 같은 process group에 속하지만, 아래 함수를 통해 원하는 process의 process group을 바꿀 수 있다.
```c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
```
Process `pid`가 속한 process group을 `pgid`로 바꾼다. `pid`가 0이면 현재 process의 PID가 사용되고, `pgid`가 0이면 `pid`를 process의 새 process group ID 로 사용한다. 
따라서 `setpgid(0, 0);`을 PID가 15213인 process가 불렀다면, process group ID가 15213인 새 process group을 생성하고, 15213 process를 그 group에 추가하게 된다.

#### Sending Signals with the /bin/kill Program
`/bin/kill -9 15213` 는 process 15213에게 9번 signal(SIGKILL)을 보낸다. <br />
`/bin/kill -9 -15213` 과 같이 PID를 음수로 쓰면 process group PID로 읽어서, process group 15213에 속하는 모든 process에게 SIGKILL을 보낸다.

#### Sending Signals from the Keyboard
Unix shell은 command line을 실행하며 생성된 process를 _job_ 이라고 추상화해서 표현하는데, 어느 시점에서든 foreground job은 많아야 한 개가 있고 background job은 0개 이상이
있을 수 있다. <br />
Shell은 각 job들을 서로 다른 process group으로 생성한다. 그리고 process group ID는 보통 부모의 것과 같기 때문에 아래 그림과 같이 foreground job의 parent process와 두 
child process는 같은 pgid 20을 가지고, 두 background job은 각각의 pgid를 가지게 된다.
![image](https://user-images.githubusercontent.com/88367636/159476585-7291ecd7-d251-4528-9aa0-07ab53f5e56b.png)
여기에서 Ctrl+C를 입력하게 되면 kernel은 foreground process group의 모든 process에게 SIGINT signal을 보낸다. 즉 foreground job의 모든 process이 종료되는 결과가 나타날 
것이다. 비슷하게, Ctrl+Z는 foreground process group의 모든 process에게 SIGSTP signal을 보낸다. 
```c
#include <unistd.h>
#include <stdio.h>

int main()
{
    while(1){
        printf("%d %d\n", getpid(), getpgrp());
        sleep(3);
    }
}
```
위와 같이 소스 코드 go.c를 짜고, 쉘에 `./go &`를 두 번 치고  `./go `를 한 번 치면 세 개의 pid가 번갈아서 출력된다.<br />
여기에 Ctrl+C를 누르면 마지막으로 친 foreground process만 종료되고 두 개의 background process의 pid만 번갈아서 출력되게 된다. Background도 종료하고 싶을 때는 위의 명령어
대로 /bin/kill -9 _PID번호_ 를 입력해 주면 된다.

#### Sending Signals with the _kill_ Function
```c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
```
위 함수는 process가 다른 process에게 signal을 보내도록 한다. `pid`가 0보다 크면 해당 process에게 보내는 것이고, `pid`가 0이면 calling process가 속한 process group의 모든
process에게 보내는 것이고, `pid`가 음수이면 |pid| process group의 모든 process에게 sig를 보낸다. 반환값은 정상일 때 0, 오류가 나면 -1이다.

#### Sending Signals with the _alarm_ Function
Process는 스스로에게 SIGALRM signal을 보낼 수 있다.
```c
#include <unistd.h>
unsigned int alarm(unsigned int secs);
```
`secs`초 후에 kernel이 스스로에게 SIGALRM을 보내도록 세팅하는 함수이다. `secs`가 0이면 아무 것도 하지 않고, 만약 pending alarm이 있는 상태에서 새 _alarm_ call이 들어온다면
나중에 들어온 call은 pending alarm을 취소하고, pending alarm이 자신이 방해하지 않았으면 종료될 때까지 남은 시간을 반환한다. Pending alarm이 없는 상태에서 _alarm_ 을 부르면
반환값은 0이 된다. <br />
조금 복잡한데, 예시를 보면 이해가 된다.
```c
#include <unistd.h>
#include <stdio.h>
int main()
{
    int a15 = alarm(15);
    int a10 = alarm(10);
    sleep(2);
    int a3 = alarm(3);
    printf("%d %d %d\n", a15, a10, a3);
    sleep(10);
}
```
먼저 15초짜리 알람은 pending alarm이 없는 상태에서 불렸기 때문에 a15에는 0이 반환된다. 10초짜리 alarm은 15초짜리 alarm이 있을 때 불렸으므로, `alarm(10)`이 불리는 즉시 
`alarm(15)`는 취소되고 a10에는 15가 저장된다. 2초 쉬고, `alarm(3)`이 불리면 8초 남은 `alarm(10)`이 취소됐으므로 a3에는 8이 저장된다. <br />
세 변수의 값이 출력된 후, `sleep(10)`이라고 걸어 줬지만 3초 뒤에 자명종이 울려서 shell에 `자명종 시계`라고 출력되고 프로그램이 종료된다.

### 8.5.3 Receiving Signals
Kernel이 process p를 kernel mode에서 user mode로 전환할 때(예: system call로부터 돌아올 때나 context switch가 끝날 때) kernel은 unblocked pending signal가 있었는지
확인한다. (pending & ~blocked) 만약 그런 signal이 없으면 p의 다음 instruction으로 control을 넘겨 주고, 그런 signal들이 있으면 그 중에서 하나 골라서 p가 receive하게 한다.
Signal을 receive하면 그에 해당하는 _action_ 을 촉발하게 되고 process가 그 _action_ 을 끝냈으면 p의 logical flow의 next instructuin으로 control을 돌려준다.<br />
각 signal type은 미리 정의된 default action이 있는데, 
- Process가 terminate
- Process가 terminate 후 dumps core
- Process가 stop(suspend) 하고 SIGCONT signal에 의해 재시작될 때까지 대기
- Process가 signal을 무시

앞에서 signal 30개 표에 각각의 default action이 명시되어 있다. SIGKILL은 default가 terminate이고, SIGCHILD는 default가 ignore이다. 하지만 process는 SIGSTOP과 SIGKILL을
제외한 signal의 default action을 아래 함수를 이용해서 수정할 수 있다. 
```c
#include <signal.h>
typedef void (*sighandler_t) (int);

sighandler_t signal(int signum, sighandler_t handler);
```
이 `signal` 함수는 `signum` signal의 action을 세 가지 중에 하나로 바꿔 준다.
- `handler`가 SIG_IGN이면 해당 `signum` 타입의 signal은 무시한다.
- `handler`가 SIG_DFL이면 해당 `signum` 타입의 signal의 action을 default action으로 되돌린다.
- `handler`가 user-defined function이면, process가 해당 `signum` 타입의 signal을 receive했을 때  _signal handler_ 를 부른다. 

세 번째 경우를  _installing the handler_ 한다 라고 부르고, handler를 호출하는 것을 _catching the signal_ 이라 하며, handler의 작업 수행은 _handling the signal_ 이라고
한다. <br />
Process가 type k의 signal을 _catch_ 하면, signal k에 _install_ 된 signal handler가 불리게 되는데 이때 argument로 정수 k를 들고 간다. 이 argument는 하나의 handler function
으로 여러 종류의 signal을 _catch_ 할 수 있게 해 준다.<br />
Handler가 일을 마치고 return을 수행하면, control은 보통 process가 interrupt됐던 instruction으로 돌아가게 된다.<br />
아래 코드는 Ctrl+C로 만들 수 있는 SIGINT signal에 handler를 install하는 과정을 보여 준다.
```c
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
void sigint_handler(int sig) {
    printf("Caught SIGINT!\n");
    exit(0);
}

int main(){
    if(signal(SIGINT, sigint_handler)==SIG_ERR){
        printf("signal error");
        exit(0);
    }
    pause();
    
    return 0;
}
```
먼저 SIGINT의 action을 default(즉시 terminate) 말고 바꿔 줄 sigint_handler를 만들어 준다. 그리고 main 함수에서 _install_ 해 주고 pause()를 걸어 준다. 그러면 사용자가
Ctrl+C를 입력하면 `sigint_handler` 함수가 실행된다.<br />
Signal handler는 다른 handler에 의해 interrupt될 수도 있다. 
![image](https://user-images.githubusercontent.com/88367636/159492853-7dc260ef-8d6b-4cf5-ac6f-9fdc9f3e821d.png)
메인 프로그램에서 signal s를 _catch_ 해서 해당 Handler인 S로 control이 넘어간다. 그런데 여기서 s와 다른 signal인 t를 _catch_ 해서, 또다른 handler T로 control이 넘어 간다.
T의 일이 끝나면 S로 돌아오고, S의 일이 끝나면 메인 프로그램으로 돌아오게 된다.<br />
연습문제 8.7이 꽤 재미있다.
<script src="https://gist.github.com/JuTaK97/5833184254ea736c6130b31decbaf305.js"></script>

### 8.5.4 Blocking and Unblocking Signals
Linux


