---
title : Chapter 8. Exceptional Control Flow (PART 2)
categories : 
  - C
tags :
  - C
last_modified_at: 2020-03-22T16:13:00-05:00
---
# Computer Systems : A Programmer's Perspective
8.1장부터 8.4장까지는 하드웨어와 소프트웨어가 협력해서 low-level exception을 제공하는 방식을 살펴보았다. 또한 운영체제가 context switch를 통해 exceptional control flow를
만들기 위해 exception을 사용하는 것을 살펴보았다. 이번 장에서는 좀 더 higher-level의 exception control flow인 Linux signal을 살펴본다. 
## 8.5 Signals
Process와 kernel이 다른 process를 interrupt하게 해 주는 _signal_ 은 일종의 작은 message로, 어떠한 종류의 event가 발생했음을 process에게 알리는 역할을 한다. 교과서 Fig 8.26에는
30종류의 Linux signal들이 나열되어 있다.<br />
각 signal 종류는 system event의 종류에 대응된다. Low-level의 hardware exception은 kernel의 exception handler에 의해 처리되고, 보통은 user process에게는 보이지 않는다. 
Signal은 이런 exception의 발생을 user process에게 알리는 역할을 한다. 예를 들어 어떤 process에서 0으로 나누려고 하면 kernel이 8번 signal인 SIGFPE를 보낸다. Illegal memory
reference를 하려 하면 kernel은 11번 SIGSEGV signal을 내보낸다.<br />
하드웨어적인 event 외에도 higher-level의 software event를 알리는 signal도 있다. 예를 들어 Ctrl+C를 누르면 kernel은 foreground에서 돌아가는 process들에게 2번 SIGINT signal을 
내보낸다. 다른 process를 강제로 종료시킬 수 있는 SIGKILL signal(9번)도 있고, child process가 terminate되거나 stop될 때 kernel이 parent에게 보내는 17번 SIGCHILD signal도 있다.
### 8.5.1 Signal Terminology
Signal의 전송은 두 단계로 구성된다.
1. _Sending a signal_
Kernel은 destination process의 context의 어떤 state를 바꾸는 것으로 signal을 전달한다. 
