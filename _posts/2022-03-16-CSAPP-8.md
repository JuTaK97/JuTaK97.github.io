---
title : Chapter 8. Exceptional Control Flow
categories : 
  - C
tags :
  - C
last_modified_at: 2020-03-16T21:13:00-05:00
---
# Computer Systems : A Programmer's Perspective
프로세서에 처음 전원을 공급할 때부터 전원을 끌 때까지, PC(program counter)는 일련의 값들을 따라 바뀌고, 각 값들은 수행할 instruction 각각의 주소가 된다. 
이러한 control transfer들을 _control flow_, 혹은 _flow of control_ 이라고 부른다.<br />
<br />
가장 간단한 형태의 control flow는 연속해서 수행하는 두 instruction이 메모리 상에서 인접한, "smooth"한 경우이다. 이런 smooth flow에 급격한 변화가 생기는 일은
jump, call, return과 같은 instruction에 의해 일어나고 이 때는 연속해서 수행되는 두 instruction이 메모리 상에서 인접하지 않는다. 이렇게 control flow에 변화를
주는 instruction들은 프로그램의 변수로 표현되는 internal program state의 변화에 프로그램이 반응하도록 하는 데 필수적이다.<br />
하지만 우리의 프로그램은 프로그램 내부의 변수들에 의해서만 program state가 바뀌지 않는다. 
- 하드웨어가 일정한 시간 간격으로 변해야 될 때도 있고, 
- 통신에서 패킷은 언제 도착할 지 모르며,
- 디스크에 요청한 데이터는 언제 로드가 완료될 지 모르고,
- parent process는 child process를 생성하고 나면 나중에 children이 종료될 때 notify 받아야 하는데, 언제 종료될 지는 아무도 모른다.

이런 상황에 반응해서 control flow에 abrupt change를 만들기 위해 _exceptional control flow_  를 만들었다. ECF는 computer system의 어떤 layer에서든 일어날 수 있는데,
하드웨어가 감지해서 abrupt control transfer를 만들기도 하고, 운영체제는 kernel이 process간에 context switch를 한다. 어플리케이션에서는 프로세스 간에 signal을 주고받으며
control transfer를 일으키기도 한다.<br />

이처럼 ECF는 꼭 뭔가 잘못된 에러 상황에서만 필요한 게 아니다. 
- ECF를 이해해야 I/O, 프로세스, 가상 메모리를 구현하기 위한 운영체제의 기본적인 매커니즘을 이해할 수 있고,
- 각 응용 프로그램들이 운영체제와 상호작용하는 것을 이해할 수 있다. 가장 대표적으로 모든 응용 프로그램은 디스크에서 데이터를 읽고 쓰고, 새 프로세스를 만들고 종료할 때
 _system call_  을 통해 커널을 호출하게 된다. 
- concurrency를 이해하기 위해서도 ECF의 이해는 필수적이다. (12장)
- 마지막으로, Java나 C++과 같은 응용 프로그램에서 exception의 동작 원리를 이해하기 위해서 ECF의 이해가 필요하다.

## 8.1 Exceptions
Exception은 일부는 하드웨어, 일부는 OS에 의해 수행되는 exceptional control flow이다. <br />
어떤 process의 _state_ 의 변화에 반응하는 control flow의 abrupt change이다. 이 _state_ 는 프로세서 내부에 여러 bit와 signal로 encode되어 있고, 이 _state_ 의 변화를 
 _event_ 라고 한다.
_event_ 는 프로그램이 수행하는 instruction에 의해 생길 수도 있다. vm의 page fault, arithmetic overflow, divide by zero 등이 대표적이다.<br />
반대로 현재 수행중인 instruction과 관련이 없이 생길 수도 있다. 대표적으로 system timer나 I/O 등이 있다.<br />

어떤 경우든 processor가 이벤트를 감지하면 indirect procedure call(=exception)을 부른다. 각 _event_ 마다 어떻게 할 지 써 있는 _exception table_ 이라는 table에 따라서
OS의 _exception handler_ 로 control transfer가 일어난다. _exception handler_ 가 할 일을 끝마치면, _event_ 의 종류에 따라 세 가지 중 하나로 이어진다.
1. current instruction, 즉 _event_ 가 발생했을 때 수행 중이던 instruction으로 돌아간다.
2. next instruction, 즉 _event_ 가 발생했을 때 수행 중이던 instruction의 다음 instruction으로 간다.
3. 그대로 프로그램을 끝낸다.

### 8.1.1 Exception Handling
하드웨어가 하는 일과 소프트웨어가 하는 일을 나눠서 살펴보자.<br />
가능한 exception의 각 종류마다 고유의 nonnegative integer가 부여되어 있는데, 이를 _exception number_ 라고 부른다. 일부는 processor를 만든 사람이 할당했고, 
일부는 OS의 커널을 만든 사람들이 할당해 놓았다. <br />
시스템이 처음 켜지면 OS는 _exception table_ 을 초기화하고 할당한다. 그러면 table의 각 entry k는 k번 exception의 handler의 주소값을 가지게 된다. Run time에 processor가
event를 감지하고 k번째 exception이구나 하고 판단하게 된다. 그러면 _exception table base register_ 라고 불리는 특별한 CPU register에다가 exception number를 더해서
table의 올바른 entry를 찾아가 해당 exception handler의 주소를 찾아가게 된다. <br />
이 과정은 기존의 procedure call과 비슷해 보이지만, 다른 점은 다음과 같다.
- Procedure call은 return address를 stack에 저장해 놓는다. 하지만 exception은 return address가 exception의 종류에 따라 current/next instruction이다.
- Exception에서는 processor가 스택에 추가적인 processor state를 저장한다. 이는 handler가 return해서 중단됐던 프로그램이 재시작될 때 필요한 정보이다.
- Kernel로 transfer될 때는 이런 정보들이 user의 stack이 아닌, kernel의 stack에 저장된다.
- Exception handler는 모든 system resource에 접근 가능한 kernel mode로 실행된다.

하드웨어가 exception을 trigger하면, 그 다음 일은 소프트웨어의 몫이다. OS가 exception handling을 끝내면 특별한 "return from interrupt" instruction을 수행해서
stack에 저장해 놨던 것들을 pop해서 되돌아 간다.

### 8.1.2 Classes of Exception
Exception은 네 가지 클래스로 나눌 수 있다.

#### 1. Interrupts
Interrupt는 나머지 셋과 달리 ascynchronic하게 일어난다. 즉 I/O signal과 같은 외부적인 요인의 결과로 발생한다.
Hardware interrupt는 이런 관점에서 asynchronous한데, instruction의 결과로 생기는 게 아니기 때문이다. 그래서 hardware interrupt에 대한 exception handler는 
interrupt handler라고도 불린다.<br />
I/O 장치는 processor의 특별한 pin을 trigger하고(1로 만들고), system bus에 해당 exception number를 태워서 보낸다. 
그 때 실행 중이던 instruction이 끝나면, processor는 pin이 high인 것을 감지하고 system bus에서 exception number를 읽고 해당 interrupt handler를 부르게 된다.<br />
Exception handler가 return하면, 아무 일도 없었다는 듯 다음 instruction을 수행한다.

#### 2. Trap
Trap는 고의로 발생시킨 exception이다. Interrupt handler처럼 trap handler는 처리가 끝나면 next instruction으로 돌아간다.<br />
Trap의 가장 중요한 사용처는 _system call_ 이다. 파일을 읽거나(read), 새 process를 만들거나(fork) 새 프로그램을 로드하는 것(execve)은 커널의 권한이 필요하다.
```syscall`` instruction을 실행하면 trap이 작동해서 exception handler가 그에 맞는 kernel routine을 부르게 된다. 사용자가 보기에는 이 과정은 일반적인 함수를 
부르는 것과 다를 게 없지만, 실제로는 user mode에서 kernel mode로 넘어가기 때문에 큰 차이가 있다.

#### 3. Faults
Fault는 unintentional하지만, recoverable 할 수 있는 exception이다. Fault handler는 fault를 처리한 후, current instruction을 다시 수행하거나 프로그램을 abort한다.<br />
대표적인 예시로 page fault가 있다. vm의 특정 주소의 page가 memory에 없을 때, fault handler는 disk에서 해당 페이지를 불러 온 후 current instruction으로 control을 넘긴다. 
그러면 이제 메모리에 해당 page가 있으므로 fault가 작동하지 않고 정상적으로 instruction이 실행된다.

#### 4. Aborts
Abort는 unintentional하고, unrecoverable한 exception이다. 주로 parity error 등의 hardware error같이 fatal error로 인해 abort가 생긴다. Abort handler는 fault처럼
처리 후 instruction으로 되돌아가지 않고 그대로 프로그램을 종료한다.

### 8.1.3 Exceptions in Linux/x86-64 Systems
x86-64 system에는 256개의 exception이 존재한다. 0\~31번은 Intel architects에서 정의된 exception이기 때문에 어느 x86-64 system이든 동일하고, 32\~255번은 OS가 정의한
interrupt와 trap이다.<br />
몇 가지 예시는 다음과 같다.
|Exception number|Description|Exception class|
|------|---|---|
|0|Divide error|Fault|
|13|General protection fault|Fault|
|14|Page fault|Fault|
|18|Machine check|Abort|

#### Linux/x86-64 Faults and Aborts

1. _Divide error_ 는 프로그램에서 0으로 나누려고 하거나 결과 값이 너무 클 때 발생한다. Unix는 그냥 프로그램을 abort하고, Linux shell은 "Floating exception"이라고 메시지를 띄운다.
2. _General protection fault_ 는 여러 가지 이유로 발생하는데, 주로 프로그램이 vm의 정의되지 않은 곳을 참조하거나, 읽기 전용인 부분에 쓰려고 할 때 발생한다. Linux는 이 fault를
recover하지 않고, Linux shell은 그 익숙한 "Segmantation faults"를 출력한다.
3. _Page fault_, _Machine check_ 는 본문 내용과 같다.

#### Linux/x86-64 System calls
Linux는 커널에게 요청할 수 있는 수백 개의 system call을 제공한다. C에서 ```syscall``` 함수를 이용해서 직접 system call을 부를 수는 있지만 보통 그렇게는 하지 않고,
C 표준 라이브러이에서 system call을 편하게 쓸 수 있는 wrapper function을 제공해 준다.<br />
이 부분의 자세한 내용은 x86-64 어셈블리어를 몰라서 패스.

## 8.2 Processes
Exception은 운영 체제의 kernel이 _process_ 를 제공하기 위한 basic building block이다. _process_ 의 고전적인 정의는 _an instance of a program in execution_ 이다. 
우리가 executable object file을 shell에 쳐서 프로그램을 실행시키면 shell은 process를 만들어서 거기서 프로그램을 돌린다. 프로그램도 그 안에서 새로운 process들을 만들기도 한다.
Process는 개별 프로그램이 시스템의 CPU와 메모리를 독점적으로 사용하는 듯 한 illusion을 제공한다. 또한, 각 프로그램이 instruction들이 끊기지 않고 순서대로 쭉 실행되는 듯한
illusion을 제공해 준다.

### 8.2.1 Logical Control Flow
Process는 각 프로그램이 CPU를 독점적으로 사용하는 듯한 illusion을 주지만, 실제로는 여러 프로그램들이 concurrently 실행 중이다. 각 프로그램들의 logical control flow는
잠시 중단되었다가 다시 실행되고, 다시 중단되었다가 다시 실행되며 여러 process가 동시에 진행된다. 프로그램 입장에서는, 중단되기 직전의 state 그대로 다시 재개되기 때문에
CPU와 메모리를 독점적으로 사용하는 것으로 인식한다. 

### 8.2.2 Concurrent Flows
두 logical flow가 시간상으로 서로 overlap 되면 concurrent flow라고 부른다. X가 1초에 시작해서 3초에 중단됐다가 다시 5초에 시작해서 8초에 끝나고, Y는 3초부터 5초까지 진행되고, 
8초부터 10초까지 Z가 실행된다고 할 때, X와 Y는 concurrent하다. 이 경우 X는 2개의 _time slice_ 로 구성되고, X와 Y의 _multitasking_ 이 일어나고 있는 것이다.

### 8.2.3 Private Address space
Process는 private address space를 통해 각 프로그램이 전체 메모리를 독점적으로 사용하는 듯한 illusion을 준다. Process는 한 프로그램에게 다른 프로세스에서 읽고 쓸 수 없는 
virtual address space를 제공한다.

### 8.2.4 User and Kernel Modes




