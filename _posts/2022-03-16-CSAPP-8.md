---
title : Chapter 8. Exceptional Control Flow
categories : 
  - C
tags :
  - C
last_modified_at: 2020-03-16T21:13:00-05:00
---
# Computer Systems : A Programmer's Perspective
프로세서에 처음 전원을 공급할 때부터 전원을 끌 때까지, PC(program counter)는 일련의 값들을 따라 바뀌고, 각 값들은 수행할 instruction 각각의 주소가 된다. 
이러한 control transfer들을 _control flow_, 혹은 _flow of control_ 이라고 부른다.<br />
<br />
가장 간단한 형태의 control flow는 연속해서 수행하는 두 instruction이 메모리 상에서 인접한, "smooth"한 경우이다. 이런 smooth flow에 급격한 변화가 생기는 일은
jump, call, return과 같은 instruction에 의해 일어나고 이 때는 연속해서 수행되는 두 instruction이 메모리 상에서 인접하지 않는다. 이렇게 control flow에 변화를
주는 instruction들은 프로그램의 변수로 표현되는 internal program state의 변화에 프로그램이 반응하도록 하는 데 필수적이다.<br />
하지만 우리의 프로그램은 프로그램 내부의 변수들에 의해서만 program state가 바뀌지 않는다. 
- 하드웨어가 일정한 시간 간격으로 변해야 될 때도 있고, 
- 통신에서 패킷은 언제 도착할 지 모르며,
- 디스크에 요청한 데이터는 언제 로드가 완료될 지 모르고,
- parent process는 child process를 생성하고 나면 나중에 children이 종료될 때 notify 받아야 하는데, 언제 종료될 지는 아무도 모른다.

이런 상황에 반응해서 control flow에 abrupt change를 만들기 위해 _exceptional control flow_  를 만들었다. ECF는 computer system의 어떤 layer에서든 일어날 수 있는데,
하드웨어가 감지해서 abrupt control transfer를 만들기도 하고, 운영체제는 kernel이 process간에 context switch를 한다. 어플리케이션에서는 프로세스 간에 signal을 주고받으며
control transfer를 일으키기도 한다.<br />

이처럼 ECF는 꼭 뭔가 잘못된 에러 상황에서만 필요한 게 아니다. 
- ECF를 이해해야 I/O, 프로세스, 가상 메모리를 구현하기 위한 운영체제의 기본적인 매커니즘을 이해할 수 있고,
- 각 응용 프로그램들이 운영체제와 상호작용하는 것을 이해할 수 있다. 가장 대표적으로 모든 응용 프로그램은 디스크에서 데이터를 읽고 쓰고, 새 프로세스를 만들고 종료할 때
 _system call_  을 통해 커널을 호출하게 된다. 
- concurrency를 이해하기 위해서도 ECF의 이해는 필수적이다. (12장)
- 마지막으로, Java나 C++과 같은 응용 프로그램에서 exception의 동작 원리를 이해하기 위해서 ECF의 이해가 필요하다.

## 8.1 Exceptions
Exception은 일부는 하드웨어, 일부는 OS에 의해 수행되는 exceptional control flow이다. <br />
어떤 process의 _state_ 의 변화에 반응하는 control flow의 abrupt change이다. 이 _state_ 는 프로세서 내부에 여러 bit와 signal로 encode되어 있고, 이 _state_ 의 변화를 
 _event_ 라고 한다.
_event_ 는 프로그램이 수행하는 instruction에 의해 생길 수도 있다. vm의 page fault, arithmetic overflow, divide by zero 등이 대표적이다.<br />
반대로 현재 수행중인 instruction과 관련이 없이 생길 수도 있다. 대표적으로 system timer나 I/O 등이 있다.<br />

어떤 경우든 processor가 이벤트를 감지하면 indirect procedure call(=exception)을 부른다. 각 _event_ 마다 어떻게 할 지 써 있는 _exception table_ 이라는 table에 따라서
OS의 _exception handler_ 로 control transfer가 일어난다. _exception handler_ 가 할 일을 끝마치면, _event_ 의 종류에 따라 세 가지 중 하나로 이어진다.
1. current instruction, 즉 _event_ 가 발생했을 때 수행 중이던 instruction으로 돌아간다.
2. next instruction, 즉 _event_ 가 발생했을 때 수행 중이던 instruction의 다음 instruction으로 간다.
3. 그대로 프로그램을 끝낸다.

### 8.1.1 Exception Handling
하드웨어가 하는 일과 소프트웨어가 하는 일을 나눠서 살펴보자.<br />
가능한 exception의 각 종류마다 고유의 nonnegative integer가 부여되어 있는데, 이를 _exception number_ 라고 부른다. 일부는 processor를 만든 사람이 할당했고, 
일부는 OS의 커널을 만든 사람들이 할당해 놓았다. <br />
시스템이 처음 켜지면 OS는 _exception table_ 을 초기화하고 할당한다. 그러면 table의 각 entry k는 k번 exception의 handler의 주소값을 가지게 된다. Run time에 processor가
event를 감지하고 k번째 exception이구나 하고 판단하게 된다. 그러면 _exception table base register_ 라고 불리는 특별한 CPU register에다가 exception number를 더해서
table의 올바른 entry를 찾아가 해당 exception handler의 주소를 찾아가게 된다. <br />
이 과정은 기존의 procedure call과 비슷해 보이지만, 다른 점은 다음과 같다.
- Procedure call은 return address를 stack에 저장해 놓는다. 하지만 exception은 return address가 exception의 종류에 따라 current/next instruction이다.
- Exception에서는 processor가 스택에 추가적인 processor state를 저장한다. 이는 handler가 return해서 중단됐던 프로그램이 재시작될 때 필요한 정보이다.
- Kernel로 transfer될 때는 이런 정보들이 user의 stack이 아닌, kernel의 stack에 저장된다.
- Exception handler는 모든 system resource에 접근 가능한 kernel mode로 실행된다.

하드웨어가 exception을 trigger하면, 그 다음 일은 소프트웨어의 몫이다. OS가 exception handling을 끝내면 특별한 "return from interrupt" instruction을 수행해서
stack에 저장해 놨던 것들을 pop해서 되돌아 간다.

### 8.1.2 Classes of Exception
Exception은 네 가지 클래스로 나눌 수 있다.

#### 1. Interrupts
Interrupt는 나머지 셋과 달리 ascynchronic하게 일어난다. 즉 I/O signal과 같은 외부적인 요인의 결과로 발생한다.
Hardware interrupt는 이런 관점에서 asynchronous한데, instruction의 결과로 생기는 게 아니기 때문이다. 그래서 hardware interrupt에 대한 exception handler는 
interrupt handler라고도 불린다.<br />
I/O 장치는 processor의 특별한 pin을 trigger하고(1로 만들고), system bus에 해당 exception number를 태워서 보낸다. 
그 때 실행 중이던 instruction이 끝나면, processor는 pin이 high인 것을 감지하고 system bus에서 exception number를 읽고 해당 interrupt handler를 부르게 된다.<br />
Exception handler가 return하면, 아무 일도 없었다는 듯 다음 instruction을 수행한다.

#### 2. Trap
Trap는 고의로 발생시킨 exception이다. 
