---
title : Linking 샅샅이 살펴보기 (2)
categories : 
  - C
tags :
  - C
last_modified_at: 2022-04-02T21:12:00-05:00
---
# Computer Systems : A Programmer's Perspective (Chapter 7)

[이전 글 - 1. 전처리기, 컴파일러, 어셈블러]

## 2. Static Linking

### 서론
앞선 글에서는 main.c와 sum.c가 따로따로 전처리기 -> 컴파일러 -> 어셈블러의 작업을 거쳐서 relocatable object file이 되는 과정을 살펴보았다.<br /><br />
`main.c`는 `sum.c`를 include하고 있기 때문에 relocatable object file `main.o` 내의 `sum.c`관련 부분은 "아직 뭔지 모른다"의 상태이다. 이런 상태의 relocatable file들을 모아서 한 번에 실행될 수 있는 fully linked executable object file을 만드는 과정이 linking이다.<br /><br />

Linking에서 해야 할 일은 두 가지이다.
1. Symbol resolution <br /> 소스 파일의 각종 변수 이름들과 함수 이름들을 _symbol_ 이라고 부른다. `main.c`의 `sum`, `array`, `val` 등이 symbol이다. Linking에서는 각 symbol들이 정화히 뭘 의미하는지를 확실히 해야 한다. 가장 익숙한 예는 지역변수이다. 전역 변수 `val1`이 있는데 지역 변수 `val1`이 또 등장할 수도 있는데, 이런 경우에 어떤 symbol이 어떤 definition에 대응되는지 정확히 1대1로 정해줘야한다.
2. Relocation <br /> 컴파일러와 어셈블러의 작업 후 생긴 relocatable object file은 binary file이다. 연속된 바이트의 배열인 이 파일에는 정해진 구역이 있는데, instruction들이 한 구역에, 초기화가 된 전역변수들이 다른 한 구역에, 그리고 초기화되지 않은 변수들이 또다른 한 구역에 위치한다. <br /> 각 relocatable object file 각각의 code section과 data section에서 모르던 남의 symbol들의 정체를 밝히고 연결시켜 줄 때, 해당 section에서 각 symbol들의 주소를 알맞게 재배치해줘야하고 이를 relocation이라고 부른다. 어셈블러가 만들어 준 _relocation entry_ 를 이용해서 작업을 진행하게 된다.


### Relocatable Object file의 구조

각 system마다 object file의 형식이 정해져 있는데, 현대의 x86-64 Linux와 Unix는 _ELF_ 라는 형식을 사용한다. 

![image](https://user-images.githubusercontent.com/88367636/161383987-cc0908e9-a124-4a2c-ab62-3efb058321b1.png)

여러 개의 구역과 맨 아래의 section header table로 구성되어 있다. <br />
맨 위의 header는 16바이트 크기로, 먼저 이 파일을 생성한 시스템의 word size와 byte ordering(Big Endian인지 Small Endian인지..)의 정보가 적혀 있다. 헤더의 나머지 부분은 linker가 이 파일을 작업할 때 parsing하고 interpret할 때 필요한 정보가 들어 있다. <br />
가장 아래에는 section header table이 있는데, object file 내에서 정해진 크기의 entry에 각 구역의 크기와 위치가 적혀 있다. <br />
일반적인 ELF reloatable object file은 다음과 같은 구역들로 구성된다.
- `.text` : 컴파일된 프로그램의 machine code가 담겨 있다.
- `.rodata` : `printf`같은 명령어의 format string이나 switch문의 jump table 같은 읽기 전용 데이터가 위치한다.
- `.data` : 초기값이 설정된(initialization) **global, static** 변수들이 위치한다. 지역 변수들은 run time에 stack에만 올라가고, 여기 외에 object file의 다른 구역에도 없다.
- `.bss` : 초기값이 설정되지 않았더나 0인 **global, static** 변수들이 위치한다. 이들은 object file에서 실제로 공간을 차지하지는 않고 그냥 틀만 존재한다. 이들은 디스크에서 공간을 차지하고 있지 않다가 run time에 초기값 0으로 메모리에 할당되게 된다.
- `symtab` : 함수와 전역 변수에 대한 symbol table이 담겨 있다.
- `rel.text` : `.text` 구역에서 다른 object file들과 linking을 통해 수정되어야 '위치'들이 담겨 있다. extern function이나 extern reference를 부르는 instruction의 '위치'는 보통 반드시 수정된다. '위치'에 대해서는 relocation에서 자세히 다룰 것이다. 이 구역은 executable object file에는 포함될 필요가 없으므로, 따로 옵션을 지정해서 linking 하지 않는 한 포함되지 않는다.
- `rel.data` : 전역 변수들의 relocation 정보가 담겨 있다. 일반적으로, 전역 변수의 주소나 외부에서 정의된 함수의 주소를 값으로 갖는 전역 변수는 수정될 것이다. 역시 relocation 부분에서 자세히 다룰 예정이다.
- `.strtab` : `.symtab` 과 `.debug`에 있는 symbol table과 section header에서 각 구역의 명칭을 위한 문자열 table이 담겨있다. Null-terminated 문자열들의 sequence로 이루어져 있다.

### Symbol, Symbol table, Symbol resolution


[이전 글 - 1. 전처리기, 컴파일러, 어셈블러]: https://jutak97.github.io/c/linking1/
